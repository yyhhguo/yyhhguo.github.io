<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>云端漫步</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>遨游知识之海</description>
    <pubDate>Mon, 13 May 2024 12:58:32 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>前端相关笔记</title>
      <link>http://example.com/2024/05/13/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/</link>
      <guid>http://example.com/2024/05/13/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Mon, 13 May 2024 02:43:11 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;路由器：&quot;&gt;&lt;a href=&quot;#路由器：&quot; class=&quot;headerlink&quot; title=&quot;路由器：&quot;&gt;&lt;/a&gt;路由器：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;路由组成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VueRouter：路由器，根据路由请求在路由视图上动态渲染对应组件。</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="路由器："><a href="#路由器：" class="headerlink" title="路由器："></a>路由器：</h2><ul><li><p>路由组成</p><ul><li>VueRouter：路由器，根据路由请求在路由视图上动态渲染对应组件。</li><li><router-link>：路由链接组件，浏览器会解析成超链接。</li><li><router-view>：路由器组件，用来展示与路由路径匹配的路由组件，可以将其类比为页面中的占位。</li></ul></li><li><p>相关流程</p><p>点击<router-link>发出路由请求到VueRouter，VueRouter根据路由路径的不同去渲染对应的组件，渲染到<router-view>的这个位置</p></li></ul><h3 id="安装路由"><a href="#安装路由" class="headerlink" title="安装路由"></a>安装路由</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router@3.5.1</span><br></pre></td></tr></table></figure><h3 id="router代码"><a href="#router代码" class="headerlink" title="router代码"></a>router代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Manage&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>( <span class="string">&#x27;../views/Manage.vue&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,<span class="comment">//组件路径</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">    <span class="comment">// route level code-splitting</span></span><br><span class="line">    <span class="comment">// this generates a separate chunk (about.[hash].js) for this route</span></span><br><span class="line">    <span class="comment">// which is lazy-loaded when the route is visited.</span></span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../views/AboutView.vue&#x27;</span>),<span class="comment">//组件所在位置</span></span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;子路由路径&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: <span class="string">&#x27;子路由组件&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">base</span>: process.<span class="property">env</span>.<span class="property">BASE_URL</span>,</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>mode</code> 选项定义了路由的模式。Vue Router 提供了两种模式：</p><ul><li>* <code>&#39;hash&#39;</code>：这是默认模式。在这种模式下，URL 会包含一个 <code>#</code> 符号，如 <code>http://example.com/#/about</code>。这种方式的好处是它对服务器没有特殊的要求，因为所有的 URL 都会发送到同一个 HTML 文件（通常是 <code>index.html</code>），然后由 Vue Router 接管。</li></ul><ul><li><code>&#39;history&#39;</code>：在这种模式下，URL 会看起来像正常的 URL，没有 <code>#</code> 符号，如 <code>http://example.com/about</code>。但是，为了正常工作，服务器需要配置以支持这种方式。当访问这样的 URL 时，服务器需要返回与 <code>index.html</code> 相同的 HTML 文件，然后由 Vue Router 接管并显示正确的视图。</li></ul><h2 id="Vuex介绍"><a href="#Vuex介绍" class="headerlink" title="Vuex介绍"></a>Vuex介绍</h2><ul><li><p>vuex是一个专门为vue.js应用程序开发的状态管理库</p></li><li><p>vuex可以在多个组件内共享数据，并且共享的数据时响应式的，及数据的变更能及时渲染到模板</p></li><li><p>vuex采用集中式存储所有组件的状态，更易管理，更规范</p></li></ul><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>ajax是一种异步无刷新技术</p><ul><li>异步：无需等待服务器返回结果，便可以执行其他程序</li><li>无刷新：做了一些操作后，页面不会刷新，依然停留在当前位置</li></ul><h3 id="同步异步对比"><a href="#同步异步对比" class="headerlink" title="同步异步对比"></a>同步异步对比</h3><p>在传统的Web应用中，当浏览器向服务器发送请求时，浏览器会等待服务器的响应，同时整个页面会被“锁定”，用户无法进行其他操作，直到服务器响应返回并处理完毕，页面才会重新“解锁”。这种方式被称为同步</p><p>在使用Ajax技术时，浏览器向服务器发送请求后，<strong>不会等待服务器的响应</strong>，而是立即返回并继续执行后续的代码。同时，浏览器会设置一个回调函数（Callback Function）来处理服务器的响应。当服务器响应返回时，浏览器会调用这个回调函数来处理响应数据，而不会阻塞用户的其他操作。这就是异步处理的方式。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在搜索引擎中，会有自动补全功能，每输入一个或几个字符，浏览器会发送一个ajax请求到服务器获取相关联想数据，如果是非异步请求，则发送请求的这一段时间，用户无法进行其他操作，会大大降低用户体验，反之，使用异步，<strong>发送请求后，浏览器不会等待服务器的响应</strong>，而是立即返回并继续执行后续的代码（如允许用户继续输入或执行其他操作）。其中的无刷新技术也可以在浏览器接到响应后不刷新整个页面，而是使用js结合DOM操作动态的将相关数据显示出来。</p><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><p>由于原生ajax过于繁杂，所以应用较少，这里介绍使用axios包装ajax请求的示例</p><h4 id="安装-axios"><a href="#安装-axios" class="headerlink" title="安装 axios"></a>安装 axios</h4><p>如果你还没有安装 <code>axios</code>，你可以使用 npm 或 yarn 来安装它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install axios  </span><br><span class="line"><span class="comment"># 或者  </span></span><br><span class="line">yarn add axios</span><br></pre></td></tr></table></figure><h4 id="使用-axios-发送-GET-请求"><a href="#使用-axios-发送-GET-请求" class="headerlink" title="使用 axios 发送 GET 请求"></a>使用 axios 发送 GET 请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 axios  </span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 发送 GET 请求到 API 地址  </span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>)  </span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;  </span><br><span class="line">    <span class="comment">// 请求成功时，处理响应数据  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);  </span><br><span class="line">  &#125;)  </span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;  </span><br><span class="line">    <span class="comment">// 请求失败时，处理错误  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);  </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="使用-axios-发送-POST-请求"><a href="#使用-axios-发送-POST-请求" class="headerlink" title="使用 axios 发送 POST 请求"></a>使用 axios 发送 POST 请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 axios  </span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 发送 POST 请求到 API 地址，并携带一些数据  </span></span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;https://api.example.com/submit&#x27;</span>, &#123;  </span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,  </span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span>  </span><br><span class="line">  &#125;)  </span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;  </span><br><span class="line">    <span class="comment">// 请求成功时，处理响应数据  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);  </span><br><span class="line">  &#125;)  </span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;  </span><br><span class="line">    <span class="comment">// 请求失败时，处理错误  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);  </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="使用-async-await-简化代码"><a href="#使用-async-await-简化代码" class="headerlink" title="使用 async&#x2F;await 简化代码"></a>使用 async&#x2F;await 简化代码</h4><p>如果你正在使用支持 <code>async/await</code> 的环境（如较新版本的 JavaScript 或 TypeScript），你可以进一步简化你的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 axios  </span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="comment">// 使用 async/await 发送 GET 请求  </span></span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>);  </span><br><span class="line">    <span class="comment">// 请求成功时，直接处理响应数据  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);  </span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;  </span><br><span class="line">    <span class="comment">// 请求失败时，处理错误  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 调用函数  </span></span><br><span class="line"><span class="title function_">fetchData</span>();</span><br></pre></td></tr></table></figure><p>使用 <code>axios</code> 可以让你更加专注于处理请求和响应数据，而不是编写复杂的错误处理和异步代码</p><h2 id="typeScript介绍"><a href="#typeScript介绍" class="headerlink" title="typeScript介绍"></a>typeScript介绍</h2><ul><li><p>为js的超集，js有的他都有，添加了类型补充</p><p>添加类型补充的好处</p><ul><li>TS属于静态类型编程语言，JS属于动态类型编程语言</li><li>静态类在编译期做类型检查，动态类在执行期做类型检查</li><li>则TS可以更早地发现问题</li></ul></li></ul>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2024/05/13/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>spring基础学习</title>
      <link>http://example.com/2024/05/10/spring%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</link>
      <guid>http://example.com/2024/05/10/spring%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Fri, 10 May 2024 12:23:04 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;SpringFrameWork&quot;&gt;&lt;a href=&quot;#SpringFrameWork&quot; class=&quot;headerlink&quot; title=&quot;SpringFrameWork&quot;&gt;&lt;/a&gt;SpringFrameWork&lt;/h2&gt;&lt;p&gt;控制反转（IOC）和面向切面编程（A</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="SpringFrameWork"><a href="#SpringFrameWork" class="headerlink" title="SpringFrameWork"></a>SpringFrameWork</h2><p>控制反转（IOC）和面向切面编程（AOP）是SpringFrameWork中最重要的两个概念</p><h3 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>IOC将对象的创建，组装和管理的控制权从应用程序代码中反转到spring的IOC容器中，由IOC容器的ApplicationContext，</p><p>实现对象的自动装配和依赖注入。</p><ul><li>控制反转（IOC,Inversion of Control）控制指的是控制对象的创建过程，反转是反转创建对象的主体由程序员转化为容器， 在spring中容器是一个单例工厂，里面的每一个对象称之为bean，我们只需要在外部创建一个bean的构建过程，真正的创建由容器负责，在启动时期bean便完成了实例化</li></ul><h4 id="Bean的装配流程"><a href="#Bean的装配流程" class="headerlink" title="Bean的装配流程"></a>Bean的装配流程</h4><p><img src="https://image.itbaima.cn/markdown/2022/12/17/Un6qjPci2uvkL5X.png"></p><p><strong>对bean的管理都是依靠BeanFactory进行，可以通过BeanFactory对Bean进行生产和管理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();  <span class="comment">//这是BeanFactory的一个默认实现类</span></span><br><span class="line">     <span class="type">BeanDefinition</span> <span class="variable">definition</span> <span class="operator">=</span> BeanDefinitionBuilder   <span class="comment">//使用BeanDefinitionBuilder快速创建Bean定义</span></span><br><span class="line">            .rootBeanDefinition(Student.class)   <span class="comment">//Bean的类型</span></span><br><span class="line">            .setScope(<span class="string">&quot;prototype&quot;</span>)    <span class="comment">//设置作用域为原型模式</span></span><br><span class="line">            .getBeanDefinition();     <span class="comment">//生成此Bean定义</span></span><br><span class="line">    <span class="comment">//相当于实在xml文件中去注册bean</span></span><br><span class="line">    factory.registerBeanDefinition(<span class="string">&quot;hello&quot;</span>, definition);   <span class="comment">//向工厂注册Bean此定义，并设定Bean的名称</span></span><br><span class="line">    System.out.println(<span class="string">&quot;获取Bean对象：&quot;</span>+factory.getBean(<span class="string">&quot;hello&quot;</span>));  <span class="comment">//我们可以直接找工厂获取Bean对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BeanDefinition</strong>是Spring框架中的一个核心概念，它描述了Bean实例的属性和行为，并提供了创建和管理Bean实例的基础信息。BeanDefinition接口定义了一个Bean的元数据，包含了用于创建Bean对象实例的所有必要信息，如Bean的类名、作用域（如singleton或prototype等）、初始化方法、销毁方法、依赖项、属性值等。</p><h5 id="BeanDefinition有多种配置方式"><a href="#BeanDefinition有多种配置方式" class="headerlink" title="BeanDefinition有多种配置方式"></a>BeanDefinition有多种配置方式</h5><ul><li>配置文件配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.bean.Student&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注解配置</li></ul><p>使用注解则更为方便，通过@Service,@Controller等便可声明为bean对象，在配置类中加入@componentScan就可以将其加入到IOC容器中进行管理，配置类中@Bean注解的方法是用来实例化并注册Bean到Spring应用上下文中的，Bean的本质还是@Service等注解的这些类。</p><h5 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;test.xml&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) context.getBean(<span class="string">&quot;student&quot;</span>);   <span class="comment">//使用getBean方法来获取对应的对象（Bean）</span></span><br><span class="line">    student.hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationContext时IOC容器中的核心接口，是BeanFactory的子接口，相较于BeanFactory有更丰富的功能和更好的性能，负责实例化，配置和管理Bean对象，以及建立这些对象间的依赖关系，当启动Spring项目时，他会创建一个ApplicationContext的实例，然后由他负责初始化和配置应用中的所有对象</p><p>现在，我们就已经知道，Bean实际上是一开始通过BeanDefinitionReader进行扫描，然后将所有Bean以BeanDefinition对象的形式注册到对应的BeanFactory中进行集中管理，而我们使用的ApplicationContext实际上内部就有一个BeanFactory在进行Bean管理，这样容器才拥有了最基本的Bean管理功能。</p><h4 id="使用IOC容器管理的好处"><a href="#使用IOC容器管理的好处" class="headerlink" title="使用IOC容器管理的好处"></a>使用IOC容器管理的好处</h4><ul><li><p>降低代码耦合度</p><p>如果不使用IOC容器管理，则两个相互依赖的类则需要手动创建出实例，如果其中一个类需要改变，则需要改变的大量代码，使用IOC容器后，则不再创建实例，而是声明需要的依赖，由容器负责在运行时注入正确的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 耦合度低的UserService示例（使用接口）  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 声明依赖，但不创建实例  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 通过构造函数注入依赖  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserRepository userRepository)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ... 其他业务方法  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// UserRepository接口  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> &#123;  </span><br><span class="line">    <span class="comment">// ... 定义方法  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// UserRepository的具体实现  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseUserRepository</span> <span class="keyword">implements</span> <span class="title class_">UserRepository</span> &#123;  </span><br><span class="line">    <span class="comment">// ... 实现方法  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 另一个UserRepository的实现（比如API调用）  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiUserRepository</span> <span class="keyword">implements</span> <span class="title class_">UserRepository</span> &#123;  </span><br><span class="line">    <span class="comment">// ... 实现方法  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p> 在这个例子中，<code>UserService</code>只依赖于<code>UserRepository</code>接口，而不是具体的实现类。这意味着我们可以轻松地替换<code>UserRepository</code>的实现，而无需修改<code>UserService</code>的代码。只需在配置文件中修改相关的代码</p><ul><li><p>安全性</p><p>在高并发情况下，如果每一步都需要new一个对象，则会增大对内存的压力，而IOC容器为单例模式，每次只需从缓存中获取，这样内存抖动不会太严重，保证程序的可靠性稳定性。</p></li></ul><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，旨在通过预编译方式和运行期间间动态代理实现程序功能的统一维护的一种技术。AOP 是对 OOP（Object-Oriented Programming，面向对象编程）的补充，用于处理系统中分布于各个模块的横切关注点（cross-cutting concerns），如日志、事务管理、安全等。这些横切关注点通常与业务逻辑无关，但会散落到各个模块中，导致代码难以维护。</p><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ol><li><strong>切面（Aspect）</strong>：切面是一个横切关注点的模块化，这个关注点可能会横切多个对象。切面用来封装横切关注点（cross-cutting concern）的代码，该代码直接影响了业务类代码的执行。</li><li><strong>连接点（Joinpoint）</strong>：是程序执行过程中某个特定的位置，例如方法执行前，方法执行后等，可以理解为终须中可能插入前面的地方</li><li><strong>通知（Advice）</strong>：在特定的连接点，AOP框架执行的动作。例如，一个方法调用前打印日志，就是一个通知。</li><li><strong>切点（Pointcut）</strong>：切点用于定义哪些连接点应该被拦截。</li></ol><p>通过切入点来匹配程序中的特定连接点，在这些连接点上执行通知，这种通知是在连接点前后执行，也可以将连接点包围起来。</p><p><strong>连接点和切点的差异</strong>：</p><ol><li><strong>定义范围</strong>：连接点是程序执行过程中的一个特定位置，是一个具体的点；而切点是一组连接点的集合，是一个更广泛的概念。</li><li><strong>作用对象</strong>：连接点是AOP可以插入额外代码或逻辑的地方，是AOP框架操作的对象；而切点则是用于指定哪些连接点需要被拦截并应用通知，是定义AOP操作范围的工具。</li><li><strong>使用方式</strong>：在AOP中，连接点通常不需要显式定义，而是由AOP框架在运行时自动识别和定位；而切点则需要显式定义，通过规则或表达式来指定需要拦截的连接点。</li></ol><p>总结来说，连接点和切点在AOP中各自扮演着不同的角色。连接点是AOP框架操作的具体位置，而切点则是用于定义AOP操作范围的工具，通过指定需要拦截的连接点来实现对程序的增强或修改。</p><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>在原始的springFramWork中，建立一个项目需要经过繁杂的依赖导入以及配置，依赖导入还经常会出现版本不匹配的问题，而SpringBoot通过其起步依赖和自动配置的特性就完美的解决了这两个问题，降低了学习成本，实现了开箱即用。</p><h3 id="启动流程（简化版）"><a href="#启动流程（简化版）" class="headerlink" title="启动流程（简化版）"></a>启动流程（简化版）</h3><ul><li>创建IOC容器  createApplicationContext(..)</li><li>加载源配置类  loadSourceClass(..)  源配置类通常是main方法所在的类，而且会被注解@SpringBootApplication所修饰，我们又称为主类。</li><li>加载并处理所有的配置类  processConfigurationClasses(..)   SpringBoot会自动找到所有配置类，然后加载处理他们。“自动配置”就属于其中的一环。</li><li>实例化所有的单例bean  instantiateSingletonBeans(..)   实例化所有的单例Bean。“依赖注入”和“自动装配”就属于其中的环节</li><li>启动web服务器</li></ul><h3 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h3><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ol><li><strong>简化配置</strong>：Spring Boot的起步依赖通过预定义和整合了常用的依赖项，极大地简化了项目的配置工作。例如，当你添加了<code>spring-boot-starter-web</code>依赖后，Spring Boot会自动配置内嵌的Web服务器、Spring MVC和其他相关组件，而无需你手动配置这些组件。</li><li><strong>快速启动</strong>：由于减少了手动配置的需要，开发者可以更快地启动和交付高质量的应用。你只需选择适合项目需求的起步依赖，Spring Boot就会自动为你处理底层的配置和依赖管理。</li><li><strong>一致性和可维护性</strong>：通过使用预定义的起步依赖，可以确保项目在不同环境和开发者之间具有一致性和可维护性。这些起步依赖都经过Spring Boot团队的精心选择和测试，以确保它们之间的兼容性和稳定性。</li><li><strong>减少错误</strong>：由于起步依赖已经处理了底层框架和库的配置和管理，因此可以减少因手动配置错误而导致的运行时问题。这有助于降低项目的风险和成本。</li><li><strong>易于扩展</strong>：虽然起步依赖为开发者提供了很多便利，但它们仍然是可扩展的。如果你需要添加或修改某个特定的依赖项，你可以很容易地在项目中添加或排除它。</li></ol><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>SpringBoot自动配置就是Spring容器启动后，一些配置类，bean对象就自动存入了IOC容器中，不需要我们手动去声明， 从而简化了开发，省去了繁杂的配置操作。</p><h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><ul><li>广义的配置类：被注解@Component直接或间接修饰的某个类，即我们常说的Spring组件，其中包括了@Configuration类</li><li>狭义的配置类：特指被注解@Configuration所修饰的某个类，又称@configuration类。</li></ul><p>如果没有特殊说明，我们说的配置类一般指广义的配置类，狭义的配置类我们一般称@Configuration类。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>从源配置类开始通过注解@ComponentScan和注解@Implort不断地递归遍历新的配置类，直到没有新的配置类被发现位置，得到的一个配置类集合，将配置类本身注册到IOC容器中，处理配置类中的@Bean方法，将其返回类型注册到IOC容器中，处理通过@Import导入的ImportBeanDefinitionRegistrar</p><p>我们的启动类上有<code>@SpringBootApplication</code></p><ul><li><p>子注解@SpringBootConfiguration，间接被@Configuration修饰，即启动类是一个源配置类</p></li><li><p>子注解@ComponentScan，对源配置类所在的Package进行组件扫描</p></li><li><p>子注解<code>@EnableAutoConfiguration</code>，最终导入一个<code>AutoConfigurationImportSelector</code>组件来实现自动配置</p></li><li><p>这个组件中会通过<code>SpringFactories机制</code>去读取<code>META-INF/spring.factories</code>文件中的所有自动配置类。这是一种SPI机制，然后根据这些自动配置类上的条件注解<code>@Conditional</code>进行过滤，过滤出满足条件的自动配置类</p></li><li><p>然后通过Spring通过实现的<code>ImportSelector</code>接口中的selectImports(..)返回一个字符串数组，内容就是扫描文件中的需要导入IOC容器中Bean的全类名，这其中还会根据这些自动配置类上的条件注解@Condition进行过滤，过滤出满足条件的自动配置类</p></li><li><p>从而得到这些自动配置类的<code>BeanDefinition</code></p></li><li><p>最后根据BeanDefinition实例化对象</p></li></ul><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><ul><li><p>@Import</p><p><code>@Import</code>注解是一个非常重要的注解，它允许你导入其他配置类、组件或配置，以便在当前的Spring上下文中使用。这个注解主要用于扩展Spring的配置和功能。</p><ul><li><p><strong>导入普通类</strong>：你可以使用@Import注解来导入一个普通类使之成为Bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(UserService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfig</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>导入配置类</strong>：你可以使用<code>@Import</code>注解来导入其他配置类，这样你就可以在一个配置类中组合多个配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@Import(AnotherConfig.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfig</span> &#123;  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>导入ImportSelector的实现</strong>：<code>ImportSelector</code>是一个接口，它允许你动态地选择并返回要导入的配置类。这对于根据条件或外部配置来加载不同的配置类特别有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfig</span> &#123;  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.example.AnotherConfig&quot;</span>&#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>导入ImportBeanDefinitionRegistrar的实现</strong>：<code>ImportBeanDefinitionRegistrar</code>接口允许你在运行时动态地注册bean定义。这给了你更多的灵活性，可以基于复杂的条件或外部输入来注册bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@Import(MyImportBeanDefinitionRegistrar.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfig</span> &#123;  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;  </span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">rootBeanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(AnotherBean.class);  </span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;anotherBean&quot;</span>, rootBeanDefinition);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2024/05/10/spring%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>苍穹外卖总结</title>
      <link>http://example.com/2024/05/04/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E6%80%BB%E7%BB%93/</link>
      <guid>http://example.com/2024/05/04/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Sat, 04 May 2024 05:35:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nginx&quot;&gt;&lt;/a&gt;Nginx&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Nginx是一个高性能的HTTP和反向代理服务器，它以其高并发处理能力和低内存占用而著称，在静态内容处理方面占有优势，因此实际生产中，经常与tomcat结合使用（tomcat为重量型服务器，处理高并发能力较弱），Nginx可以作为Tomcat的前端服务器，提供静态文件服务（如HTML、CSS、JavaScript等），并作为反向代理服务器将请求转发给Tomcat。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><p>提高访问速度</p><p>在单次请求和高并发请求环境下，Nginx都会比其他web服务器相应的更快，Nginx之所以有这么大的高并发处理能力，在于其采用了多进程和I&#x2F;O多路复用的底层实现</p></li><li><p>进行负载平衡</p><p>所谓负载平衡额就是把大量请求按照我们所指定的方式均衡的分配给集群中的每台服务器</p></li><li><p>保证后端服务安全</p><p>通过反向代理，隐藏真实的服务器IP地址</p></li><li><p>热部署</p><p>互联网项目要求7*24小时的进行提供服务，针对这一要求，Nginx提供了热部署功能，即可以在Nginx不停止的情况下，对Nginx进行文件升级，更新配置和更换日志文件。</p></li></ul><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><ol><li><strong>定义与原理</strong>：反向代理是以代理服务器来接受互联网上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给互联网上请求连接的客户端。此时，代理服务器对外就表现为一个服务器。</li><li><strong>主要功能</strong>：反向代理的主要功能包括负载均衡（分发流量到多台服务器上，保证服务的可用性和稳定性）、缓存（缓存动态或静态内容，减轻后端服务器的压力，提高页面访问速度）、安全性（隐藏真实的服务器IP地址，提高系统的安全性和隐私性）以及压缩（对页面进行压缩，减少页面的大小，提高页面的加载速度）。</li></ol><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal:"></a>ThreadLocal:</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>ThreadLocal并不是一个Thread(线程),而是Thread的一个局部变量</p><p>ThreadLocal为每一个线程提供单独一份的存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。换句话说，<code>ThreadLocal</code> 为每个线程提供了其自己的变量副本，因此每个线程都可以独立地改变自己的副本，而不会影响其他线程的副本。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li><p><strong>创建 ThreadLocal 实例</strong>：</p><p>使用 <code>ThreadLocal</code> 类，我们首先需要创建一个 <code>ThreadLocal</code> 实例，然后可以通过这个实例来访问线程局部变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></li><li><p><strong>设置和获取值</strong>：</p><ul><li><code>set(T value)</code>: 用于在当前线程中设置线程局部变量的值。</li><li><code>get()</code>: 用于获取当前线程中线程局部变量的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.set(<span class="string">&quot;Thread-A Value&quot;</span>);  </span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get(); <span class="comment">// 在当前线程中，这将返回 &quot;Thread-A Value&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>初始值</strong></p><p>默认情况下，如果没有为 <code>ThreadLocal</code> 设置值，那么调用 <code>get()</code> 方法将返回 <code>null</code>。但我们可以提供一个初始值，通过覆盖 <code>ThreadLocal</code> 的 <code>initialValue()</code> 方法来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">initialValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Initial Value&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>ThreadLocal</code> 可能会导致内存泄漏，因为它会在线程的生命周期内保持其值。如果线程长时间运行，并且 <code>ThreadLocal</code> 变量不再需要，但线程没有结束，那么这些变量占用的内存就无法被垃圾回收器回收。因此，在使用完 <code>ThreadLocal</code> 后，最好手动调用 <code>remove()</code> 方法来清除线程局部变量。</li><li><code>ThreadLocal</code> 不是解决并发问题的银弹。在大多数情况下，应该优先考虑使用同步机制（如 <code>synchronized</code> 或 <code>Lock</code>）来确保线程安全。<code>ThreadLocal</code> 只是在某些特定场景下提供了一种更优雅的解决方案。</li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis是一个基于内存的key-value结构数据库,与之对应的mysql是基于磁盘的数据库</p><p>由于基于内存存储，所以他的读写性能高，适用于储存热点数据（短时间大量访问数据）如热点商品，资讯，新闻</p><p>而mysql这种传统的数据库是基于磁盘IO进行数据读取，随着访问量的增大，这种读取方式劣势明显，于是redis应运而生</p><h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><ul><li>性能极高</li><li>数据类型丰富，单键值对最大支持512M大小的数据</li><li>简单易用，支持所有主流编程语言</li><li>支持数据持久化，主从复制，哨兵模式等高可用特性</li></ul><h3 id="springBoot整合redis"><a href="#springBoot整合redis" class="headerlink" title="springBoot整合redis"></a>springBoot整合redis</h3><h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">  <span class="comment">#Redis服务器地址</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.3</span></span><br><span class="line">    <span class="comment">#端口</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment">#使用几号数据库</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>starter已经给我们提供了两个默认的模板类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;RedisOperations.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisAutoConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">        name = &#123;&quot;redisTemplate&quot;&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">    <span class="keyword">public</span> StringRedisTemplate <span class="title function_">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>(redisConnectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需注入StringRedisTemplate来使用模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringBootTestApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; operations = template.opsForValue();</span><br><span class="line">        operations.set(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;xxxxx&quot;</span>);   <span class="comment">//设置值</span></span><br><span class="line">        System.out.println(operations.get(<span class="string">&quot;c&quot;</span>));   <span class="comment">//获取值</span></span><br><span class="line">      </span><br><span class="line">        template.delete(<span class="string">&quot;c&quot;</span>);    <span class="comment">//删除键</span></span><br><span class="line">        System.out.println(template.hasKey(<span class="string">&quot;c&quot;</span>));   <span class="comment">//判断是否包含键</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>WebSocket是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工通信——浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。</p><p>过程：客户端向服务端发送一个请求（HandShake）握手，服务端对客户端进行应答（Acknowledgement）,这样，客户端与服务端便建立好链接，双方可以进行双向通信。 </p><h3 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h3><ul><li><p>双向实时通信</p><p>允许在单个，长时间的链接上进行双向实时通信。在需要快速实时更新的应用程序里，比Http更加高效。</p></li><li><p>降低延迟</p><p>连接一旦建立便会保持开放，数据可以在客户端和服务器之间以比HTTP更低的延迟进行传输</p></li><li><p>更高效的资源利用</p><p>可以减少重复的请求和响应的开销，因为它的链接只需建立一次。</p><p>​</p></li></ul><p></p><h3 id="建立webSocket链接"><a href="#建立webSocket链接" class="headerlink" title="建立webSocket链接"></a>建立webSocket链接</h3><p>需要通过HTTP发送一次常规的Get请求，并在请求头中带上Upgrade，告诉服务器，要求从HTTP升级为webSocket，链接便建立成功，之后客户端和服务端就可以进行互相通信。</p><h3 id="使用代码"><a href="#使用代码" class="headerlink" title="使用代码"></a>使用代码</h3><h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServerEndpointExporter <span class="title function_">serverEndpointExporter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServerEndpointExporter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一旦ServerEndpointExporter被注册为bean，Spring就会扫描你的应用程序中的@ServerEndpoint注解，并自动配置  和注册相应的WebSocket端点。这使得你能够很容易地将WebSocket集成到Spring应用程序中。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WebSocket的服务"><a href="#WebSocket的服务" class="headerlink" title="WebSocket的服务"></a>WebSocket的服务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/ws/&#123;sid&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放会话对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Session&gt; sessionMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接建立成功调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session, <span class="meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端：&quot;</span> + sid + <span class="string">&quot;建立连接&quot;</span>);</span><br><span class="line">        sessionMap.put(sid, session);<span class="comment">//存放会话对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送过来的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, <span class="meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到来自客户端：&quot;</span> + sid + <span class="string">&quot;的信息:&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sid</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(<span class="meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接断开:&quot;</span> + sid);</span><br><span class="line">        sessionMap.remove(sid);<span class="comment">//移除该会话对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 群发</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendToAllClient</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        Collection&lt;Session&gt; sessions = sessionMap.values();<span class="comment">//获取所有客户端</span></span><br><span class="line">        <span class="keyword">for</span> (Session session : sessions) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//服务器向客户端发送消息</span></span><br><span class="line">                session.getBasicRemote().sendText(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HTTP</p><p>HTTP也是基于TCP的一种协议。请求响应模式，只有客户端向服务端发送请求，服务端才可以响应，不可颠倒，响应过后链接断开，故可称其为短链接</p><h2 id="JWT相关总结"><a href="#JWT相关总结" class="headerlink" title="JWT相关总结"></a>JWT相关总结</h2><p>（1）令牌的生成：由三部分组成，需要设置令牌的签名算法和签名密钥（保密，只能自己拥有，可随意设置）,过期时间，和主题数据（一般为用户id）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String secretKey, <span class="type">long</span> ttlMillis, Map&lt;String, Object&gt; claims)</span> &#123;</span><br><span class="line">    <span class="comment">// 指定签名的时候使用的签名算法，也就是header那部分</span></span><br><span class="line">    <span class="type">SignatureAlgorithm</span> <span class="variable">signatureAlgorithm</span> <span class="operator">=</span> SignatureAlgorithm.HS256;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成JWT的时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">expMillis</span> <span class="operator">=</span> System.currentTimeMillis() + ttlMillis;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(expMillis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置jwt的body</span></span><br><span class="line">    <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">            <span class="comment">// 如果有私有声明，一定要先设置这个自己创建的私有的声明，这个是给builder的claim赋值，一旦写在标准的声明赋值之后，就是覆盖了那些标准的声明的</span></span><br><span class="line">            .setClaims(claims)</span><br><span class="line">            <span class="comment">// 设置签名使用的签名算法和签名使用的秘钥</span></span><br><span class="line">            .signWith(signatureAlgorithm, secretKey.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">            <span class="comment">// 设置过期时间</span></span><br><span class="line">            .setExpiration(exp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> builder.compact();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 令牌的校验：即token的解密，通过JWTs的parser方法，设置密钥，以及需要解析的token，如果该过程为出异常，及说明令牌的校验成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWT</span><span class="params">(String secretKey, String token)</span> &#123;</span><br><span class="line">    <span class="comment">// 得到DefaultJwtParser</span></span><br><span class="line">    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">            <span class="comment">// 设置签名的秘钥</span></span><br><span class="line">            .setSigningKey(secretKey.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">            <span class="comment">// 设置需要解析的jwt</span></span><br><span class="line">            .parseClaimsJws(token).getBody();</span><br><span class="line">    <span class="keyword">return</span> claims;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两点通常封装在一个util类中，以便登陆时进行校验</p><p>(3)登录时所需要的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/employee&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeService employeeService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtProperties jwtProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> employeeLoginDTO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;EmployeeLoginVO&gt; <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> EmployeeLoginDTO employeeLoginDTO)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;员工登录：&#123;&#125;&quot;</span>, employeeLoginDTO);</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeService.login(employeeLoginDTO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//登录成功后，生成jwt令牌</span></span><br><span class="line">        Map&lt;String, Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        claims.put(JwtClaimsConstant.EMP_ID, employee.getId());</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtil.createJWT(</span><br><span class="line">                jwtProperties.getAdminSecretKey(),</span><br><span class="line">                jwtProperties.getAdminTtl(),</span><br><span class="line">                claims);</span><br><span class="line"></span><br><span class="line">        <span class="type">EmployeeLoginVO</span> <span class="variable">employeeLoginVO</span> <span class="operator">=</span> EmployeeLoginVO.builder()</span><br><span class="line">                .id(employee.getId())</span><br><span class="line">                .userName(employee.getUsername())</span><br><span class="line">                .name(employee.getName())</span><br><span class="line">                .token(token)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(employeeLoginVO);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>(4)拦截器的设置（interceptor）根据验证jwt来判断是否登录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtTokenAdminInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtProperties jwtProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验jwt</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//判断当前拦截到的是Controller的方法还是其他资源</span></span><br><span class="line">        <span class="keyword">if</span> (!(handler <span class="keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="comment">//当前拦截到的不是动态方法，直接放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、从请求头中获取令牌</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(jwtProperties.getAdminTokenName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、校验令牌</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;jwt校验:&#123;&#125;&quot;</span>, token);</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);</span><br><span class="line">            <span class="type">Long</span> <span class="variable">empId</span> <span class="operator">=</span> Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());</span><br><span class="line">            log.info(<span class="string">&quot;当前员工id：&quot;</span>, empId);</span><br><span class="line">            BaseContext.setCurrentId(empId);</span><br><span class="line">            <span class="comment">//3、通过，放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">//4、不通过，响应401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="消息推送的常见方式"><a href="#消息推送的常见方式" class="headerlink" title="消息推送的常见方式"></a>消息推送的常见方式</h2><p>（1）轮询：浏览器以指定的时间间隔向服务器发送HTTP请求，服务器实时返回数据给浏览器</p><p>   缺点：1-由于定时发送请求，可能会导致服务器数据更新，此时浏览器未发送请求，则会造成延迟</p><p>​               2-由于定时要向服务器发送请求，会造成服务器压力过大</p><p>（2）长轮询：浏览器发出ajax请求，服务器端收到请求后，会阻塞请求直到有数据或请求超时才返回</p><p>对比：由于有等待的过程，所以间隔时间可以长一些，相对于轮询对服务端造成的压力小。</p><p>并且由于必须收到数据才可返回，相对于轮询的延迟也会小。</p><p>（3）SSE 服务器发送事件</p><p>是服务端打开的和客户端之间的一个单向通道。  服务端相应的不再是一次性的数据包，而是text&#x2F;event-stream类型的数据流信息。  服务器有数据变更时将数据流式传输到客户端。</p><p>（4）WebSocket：如上。</p><p>补充：全双工：允许数据在两个方向上同时传输。</p><p>​           半双工：允许数据在两个方向上传输，但是同一个时间段内只允许一个方向上传输。</p><p>JAVA WebSocket应用由一系列的EndPoint组成。EndPoint是一个java对象，代表WebSocket链接的一端</p><p>每一个客户端，服务端都会创建一个EndPoint与之一对一对应，对于服务端，我们可以视为处理具体WebSocket消息的接口</p><p>EndPoint实例在WebSocket握手时创建，并在客户端与服务端连接过程中有效，最后在连接关闭时结束</p><p>服务端API</p><p>发送消息：1-服务端接受客户端发送的数据 常用：注解式@OnMessage</p><p>​         2-服务端推送数据给客户端：由RemoteEndpoint完成，实例由Session维护</p><p>​         通过session.getBasicRemote获取同步消息发送的实例，调用sendXXX()发送消息</p><p>​         通过session.getAsyncRemote获取异步消息发送的实例，调用sendXXX()发送消息</p><h2 id="AOP-面向切面"><a href="#AOP-面向切面" class="headerlink" title="AOP:面向切面"></a>AOP:面向切面</h2><p>动态代理是面向切面编程最主流的实现。而springAOP是spring框架的高级技术，旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程。对特定的方法功能进行加强或改变其功能。</p><p>好处：代码无侵入，减少重复代码，提高开发效率，维护方便</p><p>核心概念</p><p>（1）连接点：joinPoint，可以被AOP控制的方法（暗含方法执行时的相关信息）</p><p>通过joinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名，方法名，方法参数。 </p><p>joinPoint可获得方法的签名，而方法签名包含了方法的名称，返回类型及参数列表</p><p>（2）通知：Advice，指那些重复的逻辑，也就是共性功能（最终体现为一个方法）</p><p>（3）切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法被执行时被应用，通常通过切点表达式实现其功能。</p><p>区别：连接点时程序中所有潜在的可插入通知的位置，切入点则是从这些连接点筛选出来的，实际要附加通知的具体位置</p><p>（4）切面：Aspect，描述通知与切入点的对应关系（通知加切入点）</p><p>（5）目标对象：Target,通知所应用的对象</p><p>切点表达式（带？可省略）execution(访问修饰符？返回值 包名.类名.?方法名（方法参数）throws 异常？)</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理是在运行时动态的为对象创建代理的技术</p><table><thead><tr><th align="center"></th><th align="center">必须实现接口</th><th align="center">支持拦截public方法</th><th align="center">支持拦截protected方法</th><th align="center">拦截默认作用域方法</th></tr></thead><tbody><tr><td align="center">JDK动态代理</td><td align="center">是</td><td align="center">是</td><td align="center">否</td><td align="center">否</td></tr><tr><td align="center">CGLIB代理</td><td align="center">否</td><td align="center">是</td><td align="center">是</td><td align="center">是</td></tr></tbody></table><p>虽然CGLIB代理支持拦截非public作用域方法调用，但不同对象交互是，建议还是以public方法调用为主</p><h2 id="文件上传（阿里云OSS）"><a href="#文件上传（阿里云OSS）" class="headerlink" title="文件上传（阿里云OSS）"></a>文件上传（阿里云OSS）</h2><h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><p>前往阿里云官方完成注册等流程，新建一个bucket，获取到如下四个数据 access-key-id  access-key-secret  endpoint  bucket-name</p><p>写在配置文件中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">alioss:</span></span><br><span class="line">  <span class="attr">access-key-id:</span> </span><br><span class="line">  <span class="attr">access-key-secret:</span> </span><br><span class="line">  <span class="attr">endpoint:</span> </span><br><span class="line">  <span class="attr">bucket-name:</span> </span><br></pre></td></tr></table></figure><p>后端相应的接口</p><ul><li>接受上传来的文件</li><li>将文件存储起来（OSS）</li><li>返回文件的url</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/common&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AliOssUtil aliOssUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt;upload(MultipartFile file)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">            <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">ObjectName</span> <span class="operator">=</span> UUID.randomUUID().toString()+extension;</span><br><span class="line">            <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> aliOssUtil.upload(file.getBytes(), ObjectName);</span><br><span class="line">            <span class="keyword">return</span> Result.success(filePath);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中所用到的工具类(有阿里云官方代码改造而来)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOssUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要为自己获取到的</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objectName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(<span class="type">byte</span>[] bytes, String objectName)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">        <span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建PutObject请求。</span></span><br><span class="line">            ossClient.putObject(bucketName, objectName, <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OSSException oe) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught an OSSException, which means your request made it to OSS, &quot;</span></span><br><span class="line">                    + <span class="string">&quot;but was rejected with an error response for some reason.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Message:&quot;</span> + oe.getErrorMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Code:&quot;</span> + oe.getErrorCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;Request ID:&quot;</span> + oe.getRequestId());</span><br><span class="line">            System.out.println(<span class="string">&quot;Host ID:&quot;</span> + oe.getHostId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException ce) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught an ClientException, which means the client encountered &quot;</span></span><br><span class="line">                    + <span class="string">&quot;a serious internal problem while trying to communicate with OSS, &quot;</span></span><br><span class="line">                    + <span class="string">&quot;such as not being able to access the network.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Message:&quot;</span> + ce.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ossClient != <span class="literal">null</span>) &#123;</span><br><span class="line">                ossClient.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件访问路径规则 https://BucketName.Endpoint/ObjectName</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;https://&quot;</span>);</span><br><span class="line">        stringBuilder</span><br><span class="line">                .append(bucketName)</span><br><span class="line">                .append(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">                .append(endpoint)</span><br><span class="line">                .append(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">                .append(objectName);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;文件上传到:&#123;&#125;&quot;</span>, stringBuilder.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2024/05/04/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E6%80%BB%E7%BB%93/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
