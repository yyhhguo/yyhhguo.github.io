<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端相关笔记</title>
      <link href="/2024/05/13/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/05/13/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="路由器："><a href="#路由器：" class="headerlink" title="路由器："></a>路由器：</h2><ul><li><p>路由组成</p><ul><li>VueRouter：路由器，根据路由请求在路由视图上动态渲染对应组件。</li><li><router-link>：路由链接组件，浏览器会解析成超链接。</li><li><router-view>：路由器组件，用来展示与路由路径匹配的路由组件，可以将其类比为页面中的占位。</li></ul></li><li><p>相关流程</p><p>点击<router-link>发出路由请求到VueRouter，VueRouter根据路由路径的不同去渲染对应的组件，渲染到<router-view>的这个位置</p></li></ul><h2 id="Vuex介绍"><a href="#Vuex介绍" class="headerlink" title="Vuex介绍"></a>Vuex介绍</h2><ul><li><p>vuex是一个专门为vue.js应用程序开发的状态管理库</p></li><li><p>vuex可以在多个组件内共享数据，并且共享的数据时响应式的，及数据的变更能及时渲染到模板</p></li><li><p>vuex采用集中式存储所有组件的状态，更易管理，更规范</p></li></ul><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><p>ajax是一种异步无刷新技术</p><ul><li>异步：无需等待服务器返回结果，便可以执行其他程序</li><li>无刷新：做了一些操作后，页面不会刷新，依然停留在当前位置</li></ul><h3 id="同步异步对比"><a href="#同步异步对比" class="headerlink" title="同步异步对比"></a>同步异步对比</h3><p>在传统的Web应用中，当浏览器向服务器发送请求时，浏览器会等待服务器的响应，同时整个页面会被“锁定”，用户无法进行其他操作，直到服务器响应返回并处理完毕，页面才会重新“解锁”。这种方式被称为同步</p><p>在使用Ajax技术时，浏览器向服务器发送请求后，<strong>不会等待服务器的响应</strong>，而是立即返回并继续执行后续的代码。同时，浏览器会设置一个回调函数（Callback Function）来处理服务器的响应。当服务器响应返回时，浏览器会调用这个回调函数来处理响应数据，而不会阻塞用户的其他操作。这就是异步处理的方式。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在搜索引擎中，会有自动补全功能，每输入一个或几个字符，浏览器会发送一个ajax请求到服务器获取相关联想数据，如果是非异步请求，则发送请求的这一段时间，用户无法进行其他操作，会大大降低用户体验，反之，使用异步，<strong>发送请求后，浏览器不会等待服务器的响应</strong>，而是立即返回并继续执行后续的代码（如允许用户继续输入或执行其他操作）。其中的无刷新技术也可以在浏览器接到响应后不刷新整个页面，而是使用js结合DOM操作动态的将相关数据显示出来。</p><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><p>由于原生ajax过于繁杂，所以应用较少，这里介绍使用axios包装ajax请求的示例</p><h4 id="安装-axios"><a href="#安装-axios" class="headerlink" title="安装 axios"></a>安装 axios</h4><p>如果你还没有安装 <code>axios</code>，你可以使用 npm 或 yarn 来安装它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install axios  </span><br><span class="line"># 或者  </span><br><span class="line">yarn add axios</span><br></pre></td></tr></table></figure><h4 id="使用-axios-发送-GET-请求"><a href="#使用-axios-发送-GET-请求" class="headerlink" title="使用 axios 发送 GET 请求"></a>使用 axios 发送 GET 请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 axios  </span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 发送 GET 请求到 API 地址  </span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>)  </span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;  </span><br><span class="line">    <span class="comment">// 请求成功时，处理响应数据  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);  </span><br><span class="line">  &#125;)  </span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;  </span><br><span class="line">    <span class="comment">// 请求失败时，处理错误  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);  </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="使用-axios-发送-POST-请求"><a href="#使用-axios-发送-POST-请求" class="headerlink" title="使用 axios 发送 POST 请求"></a>使用 axios 发送 POST 请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 axios  </span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 发送 POST 请求到 API 地址，并携带一些数据  </span></span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;https://api.example.com/submit&#x27;</span>, &#123;  </span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,  </span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span>  </span><br><span class="line">  &#125;)  </span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;  </span><br><span class="line">    <span class="comment">// 请求成功时，处理响应数据  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);  </span><br><span class="line">  &#125;)  </span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;  </span><br><span class="line">    <span class="comment">// 请求失败时，处理错误  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);  </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="使用-async-await-简化代码"><a href="#使用-async-await-简化代码" class="headerlink" title="使用 async&#x2F;await 简化代码"></a>使用 async&#x2F;await 简化代码</h4><p>如果你正在使用支持 <code>async/await</code> 的环境（如较新版本的 JavaScript 或 TypeScript），你可以进一步简化你的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 axios  </span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="comment">// 使用 async/await 发送 GET 请求  </span></span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>);  </span><br><span class="line">    <span class="comment">// 请求成功时，直接处理响应数据  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);  </span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;  </span><br><span class="line">    <span class="comment">// 请求失败时，处理错误  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 调用函数  </span></span><br><span class="line"><span class="title function_">fetchData</span>();</span><br></pre></td></tr></table></figure><p>使用 <code>axios</code> 可以让你更加专注于处理请求和响应数据，而不是编写复杂的错误处理和异步代码</p><h2 id="typeScript介绍"><a href="#typeScript介绍" class="headerlink" title="typeScript介绍"></a>typeScript介绍</h2><ul><li><p>为js的超集，js有的他都有，添加了类型补充</p><p>添加类型补充的好处</p><ul><li>TS属于静态类型编程语言，JS属于动态类型编程语言</li><li>静态类在编译期做类型检查，动态类在执行期做类型检查</li><li>则TS可以更早地发现问题</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring基础学习</title>
      <link href="/2024/05/10/spring%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/05/10/spring%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>IOC将对象的创建，组装和管理的控制权从应用程序代码中反转到spring的IOC容器中，由IOC容器的ApplicationContext，</p><p>实现对象的自动装配和依赖注入，自动装配体现在代码中就是（以注解为例）@Service,@Mapper…….，</p><p>依赖注入体现在代码中就是@Autoweird,@Resource。如此避免了在业务层中反复new对象。</p><ul><li>控制反转（IOC,Inversion of Control）控制指的是控制对象的创建过程，反转是反转创建对象的主体由程序员转化为容器， 在spring中容器是一个单例工厂，里面的每一个对象称之为bean，我们只需要在外部创建一个bean的构建过程，真正的创建由容器负责，在启动时期bean便完成了实例化</li></ul><h4 id="2-Bean的装配流程"><a href="#2-Bean的装配流程" class="headerlink" title="2.Bean的装配流程"></a>2.Bean的装配流程</h4><p>某个类中，添加@component注解后，项目在启动时，会执行Bean装配流程</p><p>项目启动 —&gt; 加载配置文件 —&gt; 根据配置文件生成bean对象 —&gt; 将bean对象上传到依赖池 —&gt; 装配完成</p><p>（1）配置文件配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在beans中通过bean将对象加入到IOC容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=<span class="string">&quot;student&quot;</span> class=<span class="string">&quot;com.test.bean.Student&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>（2）注解配置</p><p>使用注解则更为方便，通过@Bean便可声明为bean对象，在配置类中加入@componentScan就可以将其加入到IOC容器中进行管理。</p><p>这样我们就不必再项目中去new一个对象使用而是可以直接从IOC容器中去取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;test.xml&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) context.getBean(<span class="string">&quot;student&quot;</span>);   <span class="comment">//使用getBean方法来获取对应的对象（Bean）</span></span><br><span class="line">    student.hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-使用IOC容器管理的好处"><a href="#3-使用IOC容器管理的好处" class="headerlink" title="3.使用IOC容器管理的好处"></a>3.使用IOC容器管理的好处</h4><ul><li><p>降低代码耦合度</p><p>如果不使用IOC容器管理，则两个相互依赖的类则需要手动创建出实例，如果其中一个类需要改变，则需要改变的大量代码，使用IOC容器后，则不再创建实例，而是声明需要的依赖，由容器负责在运行时注入正确的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 耦合度低的UserService示例（使用接口）  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 声明依赖，但不创建实例  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 通过构造函数注入依赖  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserRepository userRepository)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ... 其他业务方法  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// UserRepository接口  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> &#123;  </span><br><span class="line">    <span class="comment">// ... 定义方法  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// UserRepository的具体实现  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseUserRepository</span> <span class="keyword">implements</span> <span class="title class_">UserRepository</span> &#123;  </span><br><span class="line">    <span class="comment">// ... 实现方法  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 另一个UserRepository的实现（比如API调用）  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiUserRepository</span> <span class="keyword">implements</span> <span class="title class_">UserRepository</span> &#123;  </span><br><span class="line">    <span class="comment">// ... 实现方法  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p> 在这个例子中，<code>UserService</code>只依赖于<code>UserRepository</code>接口，而不是具体的实现类。这意味着我们可以轻松地替换<code>UserRepository</code>的实现，而无需修改<code>UserService</code>的代码。只需在配置文件中修改相关的代码</p><ul><li><p>安全性</p><p>在高并发情况下，如果每一步都需要new一个对象，则会增大对内存的压力，而IOC容器为单例模式，每次只需从缓存中获取，这样内存抖动不会太严重，保证程序的可靠性稳定性。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>苍穹外卖总结</title>
      <link href="/2024/05/04/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E6%80%BB%E7%BB%93/"/>
      <url>/2024/05/04/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx反向代理的好处："><a href="#Nginx反向代理的好处：" class="headerlink" title="Nginx反向代理的好处："></a>Nginx反向代理的好处：</h2><ul><li>提高访问速度</li><li>进行负载平衡：所谓负载平衡额就是把大量请求按照我们所指定的方式均衡的分配给集群中的每台服务器</li><li>保证后端服务安全</li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal:"></a>ThreadLocal:</h2><p>ThreadLocal并不是一个Thread(线程),而是Thread的一个局部变量</p><p>ThreadLocal为每一个线程提供单独一份的存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis是一个基于内存的key-value结构数据库,与之对应的mysql是基于磁盘的数据库</p><p>由于基于内存存储，所以他的读写性能高，适用于储存热点数据（短时间大量访问数据）如热点商品，资讯，新闻</p><p>而mysql这种传统的数据库是基于磁盘IO进行数据读取，随着访问量的增大，这种读取方式劣势明显，于是redis应运而生</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>性能极高</li><li>数据类型丰富，单键值对最大支持512M大小的数据</li><li>简单易用，支持所有主流编程语言</li><li>支持数据持久化，主从复制，哨兵模式等高可用特性</li></ul><h3 id="springBoot整合redis"><a href="#springBoot整合redis" class="headerlink" title="springBoot整合redis"></a>springBoot整合redis</h3><h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">  <span class="comment">#Redis服务器地址</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.3</span></span><br><span class="line">    <span class="comment">#端口</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment">#使用几号数据库</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>starter已经给我们提供了两个默认的模板类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;RedisOperations.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisAutoConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">        name = &#123;&quot;redisTemplate&quot;&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">    <span class="keyword">public</span> StringRedisTemplate <span class="title function_">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>(redisConnectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需注入StringRedisTemplate来使用模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringBootTestApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; operations = template.opsForValue();</span><br><span class="line">        operations.set(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;xxxxx&quot;</span>);   <span class="comment">//设置值</span></span><br><span class="line">        System.out.println(operations.get(<span class="string">&quot;c&quot;</span>));   <span class="comment">//获取值</span></span><br><span class="line">      </span><br><span class="line">        template.delete(<span class="string">&quot;c&quot;</span>);    <span class="comment">//删除键</span></span><br><span class="line">        System.out.println(template.hasKey(<span class="string">&quot;c&quot;</span>));   <span class="comment">//判断是否包含键</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工通信——浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。</p><p>过程：客户端向服务端发送一个请求（HandShake）握手，服务端对客户端进行应答（Acknowledgement）,这样，客户端与服务端便建立好链接，双方可以进行双向通信。 </p><p>HTTP</p><p>HTTP也是基于TCP的一种协议。请求响应模式，只有客户端向服务端发送请求，服务端才可以响应，不可颠倒，响应过后链接断开，故可称其为短链接</p><h2 id="JWT相关总结"><a href="#JWT相关总结" class="headerlink" title="JWT相关总结"></a>JWT相关总结</h2><p>（1）令牌的生成：由三部分组成，需要设置令牌的签名算法和签名密钥（保密，只能自己拥有，可随意设置）,过期时间，和主题数据（一般为用户id）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String secretKey, <span class="type">long</span> ttlMillis, Map&lt;String, Object&gt; claims)</span> &#123;</span><br><span class="line">    <span class="comment">// 指定签名的时候使用的签名算法，也就是header那部分</span></span><br><span class="line">    <span class="type">SignatureAlgorithm</span> <span class="variable">signatureAlgorithm</span> <span class="operator">=</span> SignatureAlgorithm.HS256;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成JWT的时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">expMillis</span> <span class="operator">=</span> System.currentTimeMillis() + ttlMillis;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(expMillis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置jwt的body</span></span><br><span class="line">    <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">            <span class="comment">// 如果有私有声明，一定要先设置这个自己创建的私有的声明，这个是给builder的claim赋值，一旦写在标准的声明赋值之后，就是覆盖了那些标准的声明的</span></span><br><span class="line">            .setClaims(claims)</span><br><span class="line">            <span class="comment">// 设置签名使用的签名算法和签名使用的秘钥</span></span><br><span class="line">            .signWith(signatureAlgorithm, secretKey.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">            <span class="comment">// 设置过期时间</span></span><br><span class="line">            .setExpiration(exp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> builder.compact();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 令牌的校验：即token的解密，通过JWTs的parser方法，设置密钥，以及需要解析的token，如果该过程为出异常，及说明令牌的校验成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWT</span><span class="params">(String secretKey, String token)</span> &#123;</span><br><span class="line">    <span class="comment">// 得到DefaultJwtParser</span></span><br><span class="line">    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">            <span class="comment">// 设置签名的秘钥</span></span><br><span class="line">            .setSigningKey(secretKey.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">            <span class="comment">// 设置需要解析的jwt</span></span><br><span class="line">            .parseClaimsJws(token).getBody();</span><br><span class="line">    <span class="keyword">return</span> claims;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两点通常封装在一个util类中，以便登陆时进行校验</p><p>(3)登录时所需要的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/employee&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeService employeeService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtProperties jwtProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> employeeLoginDTO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;EmployeeLoginVO&gt; <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> EmployeeLoginDTO employeeLoginDTO)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;员工登录：&#123;&#125;&quot;</span>, employeeLoginDTO);</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeService.login(employeeLoginDTO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//登录成功后，生成jwt令牌</span></span><br><span class="line">        Map&lt;String, Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        claims.put(JwtClaimsConstant.EMP_ID, employee.getId());</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtil.createJWT(</span><br><span class="line">                jwtProperties.getAdminSecretKey(),</span><br><span class="line">                jwtProperties.getAdminTtl(),</span><br><span class="line">                claims);</span><br><span class="line"></span><br><span class="line">        <span class="type">EmployeeLoginVO</span> <span class="variable">employeeLoginVO</span> <span class="operator">=</span> EmployeeLoginVO.builder()</span><br><span class="line">                .id(employee.getId())</span><br><span class="line">                .userName(employee.getUsername())</span><br><span class="line">                .name(employee.getName())</span><br><span class="line">                .token(token)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(employeeLoginVO);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>(4)拦截器的设置（interceptor）根据验证jwt来判断是否登录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtTokenAdminInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtProperties jwtProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验jwt</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//判断当前拦截到的是Controller的方法还是其他资源</span></span><br><span class="line">        <span class="keyword">if</span> (!(handler <span class="keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="comment">//当前拦截到的不是动态方法，直接放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、从请求头中获取令牌</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(jwtProperties.getAdminTokenName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、校验令牌</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;jwt校验:&#123;&#125;&quot;</span>, token);</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);</span><br><span class="line">            <span class="type">Long</span> <span class="variable">empId</span> <span class="operator">=</span> Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());</span><br><span class="line">            log.info(<span class="string">&quot;当前员工id：&quot;</span>, empId);</span><br><span class="line">            BaseContext.setCurrentId(empId);</span><br><span class="line">            <span class="comment">//3、通过，放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">//4、不通过，响应401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="消息推送的常见方式"><a href="#消息推送的常见方式" class="headerlink" title="消息推送的常见方式"></a>消息推送的常见方式</h2><p>（1）轮询：浏览器以指定的时间间隔向服务器发送HTTP请求，服务器实时返回数据给浏览器</p><p>   缺点：1-由于定时发送请求，可能会导致服务器数据更新，此时浏览器未发送请求，则会造成延迟</p><p>​               2-由于定时要向服务器发送请求，会造成服务器压力过大</p><p>（2）长轮询：浏览器发出ajax请求，服务器端收到请求后，会阻塞请求直到有数据或请求超时才返回</p><p>对比：由于有等待的过程，所以间隔时间可以长一些，相对于轮询对服务端造成的压力小。</p><p>并且由于必须收到数据才可返回，相对于轮询的延迟也会小。</p><p>（3）SSE 服务器发送事件</p><p>是服务端打开的和客户端之间的一个单向通道。  服务端相应的不再是一次性的数据包，而是text&#x2F;event-stream类型的数据流信息。  服务器有数据变更时将数据流式传输到客户端。</p><p>（4）WebSocket：如上。</p><p>补充：全双工：允许数据在两个方向上同时传输。</p><p>​           半双工：允许数据在两个方向上传输，但是同一个时间段内只允许一个方向上传输。</p><p>JAVA WebSocket应用由一系列的EndPoint组成。EndPoint是一个java对象，代表WebSocket链接的一端</p><p>每一个客户端，服务端都会创建一个EndPoint与之一对一对应，对于服务端，我们可以视为处理具体WebSocket消息的接口</p><p>EndPoint实例在WebSocket握手时创建，并在客户端与服务端连接过程中有效，最后在连接关闭时结束</p><p>服务端API</p><p>发送消息：1-服务端接受客户端发送的数据 常用：注解式@OnMessage</p><p>​         2-服务端推送数据给客户端：由RemoteEndpoint完成，实例由Session维护</p><p>​         通过session.getBasicRemote获取同步消息发送的实例，调用sendXXX()发送消息</p><p>​         通过session.getAsyncRemote获取异步消息发送的实例，调用sendXXX()发送消息</p><h2 id="AOP-面向切面"><a href="#AOP-面向切面" class="headerlink" title="AOP:面向切面"></a>AOP:面向切面</h2><p>动态代理是面向切面编程最主流的实现。而springAOP是spring框架的高级技术，旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程。对特定的方法功能进行加强或改变其功能。</p><p>好处：代码无侵入，减少重复代码，提高开发效率，维护方便</p><p>核心概念</p><p>（1）连接点：joinPoint，可以被AOP控制的方法（暗含方法执行时的相关信息）</p><p>通过joinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名，方法名，方法参数。 </p><p>joinPoint可获得方法的签名，而方法签名包含了方法的名称，返回类型及参数列表</p><p>（2）通知：Advice，指那些重复的逻辑，也就是共性功能（最终体现为一个方法）</p><p>（3）切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法被执行时被应用，通常通过切点表达式实现其功能。</p><p>区别：连接点时程序中所有潜在的可插入通知的位置，切入点则是从这些连接点筛选出来的，实际要附加通知的具体位置</p><p>（4）切面：Aspect，描述通知与切入点的对应关系（通知加切入点）</p><p>（5）目标对象：Target,通知所应用的对象</p><p>切点表达式（带？可省略）execution(访问修饰符？返回值 包名.类名.?方法名（方法参数）throws 异常？)</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理是在运行时动态的为对象创建代理的技术</p><table><thead><tr><th align="center"></th><th align="center">必须实现接口</th><th align="center">支持拦截public方法</th><th align="center">支持拦截protected方法</th><th align="center">拦截默认作用域方法</th></tr></thead><tbody><tr><td align="center">JDK动态代理</td><td align="center">是</td><td align="center">是</td><td align="center">否</td><td align="center">否</td></tr><tr><td align="center">CGLIB代理</td><td align="center">否</td><td align="center">是</td><td align="center">是</td><td align="center">是</td></tr></tbody></table><p>虽然CGLIB代理支持拦截非public作用域方法调用，但不同对象交互是，建议还是以public方法调用为主</p><h2 id="文件上传（阿里云OSS）"><a href="#文件上传（阿里云OSS）" class="headerlink" title="文件上传（阿里云OSS）"></a>文件上传（阿里云OSS）</h2><h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><p>前往阿里云官方完成注册等流程，新建一个bucket，获取到如下四个数据 access-key-id  access-key-secret  endpoint  bucket-name</p><p>写在配置文件中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">alioss:</span></span><br><span class="line">  <span class="attr">access-key-id:</span> </span><br><span class="line">  <span class="attr">access-key-secret:</span> </span><br><span class="line">  <span class="attr">endpoint:</span> </span><br><span class="line">  <span class="attr">bucket-name:</span> </span><br></pre></td></tr></table></figure><p>后端相应的接口</p><ul><li>接受上传来的文件</li><li>将文件存储起来（OSS）</li><li>返回文件的url</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/common&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AliOssUtil aliOssUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt;upload(MultipartFile file)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">            <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">ObjectName</span> <span class="operator">=</span> UUID.randomUUID().toString()+extension;</span><br><span class="line">            <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> aliOssUtil.upload(file.getBytes(), ObjectName);</span><br><span class="line">            <span class="keyword">return</span> Result.success(filePath);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中所用到的工具类(有阿里云官方代码改造而来)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOssUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要为自己获取到的</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objectName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(<span class="type">byte</span>[] bytes, String objectName)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">        <span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建PutObject请求。</span></span><br><span class="line">            ossClient.putObject(bucketName, objectName, <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OSSException oe) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught an OSSException, which means your request made it to OSS, &quot;</span></span><br><span class="line">                    + <span class="string">&quot;but was rejected with an error response for some reason.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Message:&quot;</span> + oe.getErrorMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Code:&quot;</span> + oe.getErrorCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;Request ID:&quot;</span> + oe.getRequestId());</span><br><span class="line">            System.out.println(<span class="string">&quot;Host ID:&quot;</span> + oe.getHostId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException ce) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught an ClientException, which means the client encountered &quot;</span></span><br><span class="line">                    + <span class="string">&quot;a serious internal problem while trying to communicate with OSS, &quot;</span></span><br><span class="line">                    + <span class="string">&quot;such as not being able to access the network.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Message:&quot;</span> + ce.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ossClient != <span class="literal">null</span>) &#123;</span><br><span class="line">                ossClient.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件访问路径规则 https://BucketName.Endpoint/ObjectName</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;https://&quot;</span>);</span><br><span class="line">        stringBuilder</span><br><span class="line">                .append(bucketName)</span><br><span class="line">                .append(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">                .append(endpoint)</span><br><span class="line">                .append(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">                .append(objectName);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;文件上传到:&#123;&#125;&quot;</span>, stringBuilder.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
