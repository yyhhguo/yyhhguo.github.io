<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker学习</title>
      <link href="/2024/05/22/Docker%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/05/22/Docker%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Docker是一个开源的应用容器引擎，它允许开发者将他们的应用及其依赖包打包到一个可移植的容器中，并发布到任何流行的Linux或Windows操作系统的机器上。Docker容器是完全使用沙箱机制，相互之间不会有任何接口，从而提供了高度的隔离性和安全性。</p><p>Docker由多个组件组成，包括Docker客户端（DockerClient）、Docker守护进程（Docker Daemon）、Docker镜像（Docker Image）和Docker容器（Docker Container）等。这些组件协同工作，使得开发者能够轻松地构建、运行和管理应用程序容器。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>以下几个方面：</p><ol><li><strong>应用程序打包</strong>：Docker可以将应用程序及其所有依赖项打包成一个称为容器的单元。这意味着，无论在哪里运行Docker，应用程序都能以相同的方式运行，从而消除了“在我的机器上工作”的问题。</li><li><strong>简化部署</strong>：使用Docker，开发人员可以创建包含所有依赖项和配置的应用程序镜像，并将其推送到Docker仓库。然后，运维人员可以从该仓库中拉取镜像，并在生产环境中运行它，无需担心环境差异。</li><li><strong>简化配置</strong>：Docker使用Dockerfile来定义应用程序的镜像。Dockerfile是一个文本文件，其中包含一组指令，用于构建Docker镜像。这些指令基于基础镜像（如Ubuntu、CentOS等），并添加应用程序所需的依赖项、文件、环境变量等。通过这种方式，开发人员可以确保应用程序在所有环境中都有相同的配置。</li><li><strong>可扩展性</strong>：Docker支持水平扩展，即可以通过添加更多的容器实例来增加处理能力。这意味着，当需要处理更多的请求或数据时，可以轻松地添加更多的容器实例，而无需修改应用程序代码或配置。</li><li><strong>隔离性</strong>：Docker容器具有高度的隔离性，每个容器都运行在自己的环境中，与其他容器和宿主机隔离。这种隔离性确保了容器之间的安全性和稳定性，避免了不同应用程序之间的冲突和干扰。</li><li><strong>轻量级和快速</strong>：Docker容器比传统的虚拟机更轻量级，因为它们共享宿主机的内核和库。这使得Docker容器能够更快地启动和停止，并且占用的资源更少。</li><li><strong>多平台支持</strong>：Docker支持多种操作系统和平台，包括Linux、Windows和macOS等。这使得开发人员可以在不同的平台上构建和运行应用程序，并确保在不同环境中的一致性。</li><li><strong>持续集成和持续部署（CI&#x2F;CD）</strong>：Docker与CI&#x2F;CD工具（如Jenkins、GitLab CI等）紧密集成，可以自动构建、测试和部署应用程序。这大大提高了开发效率，并减少了手动错误的可能性。</li><li><strong>版本控制</strong>：Docker镜像可以像代码一样进行版本控制。这意味着，可以轻松地跟踪和管理应用程序的更改，并回滚到以前的版本（如果需要）。</li><li><strong>社区支持</strong>：Docker有一个庞大的社区，提供了大量的教程、示例、工具和插件。这使得学习和使用Docker变得更加容易，并且可以获得来自社区的支持和帮助。</li></ol><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h3><p>当我们利用Docker安装应用时，Docker会自动搜索并下载应用<strong>镜像（image）</strong>。镜像不仅包含应用本身，还包含应用运行所需的环境，配置，系统函数库。Docker会在运行镜像时创建一个隔离环境，称为<strong>容器(container)</strong></p><p>由于镜像还打包了自身所需要的环境，配置，系统函数库，这使其可以在不同系统环境下运行，也就是说Docker的镜像可以忽略操作系统的环境，忽略系统本身的差异而去直接部署，而其中创建的隔离环境-容器，这使之我们可以在一台服务器中部署多个应用，从而做的互不打扰，减少了资源的浪费</p><h3 id="下载实例（部署Mysql）"><a href="#下载实例（部署Mysql）" class="headerlink" title="下载实例（部署Mysql）"></a>下载实例（部署Mysql）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mysql -p 3306:3306 -e TZ=Aisa/Shanghai -e MYSQL_ROOT_PASSWORD=123 mysql</span><br></pre></td></tr></table></figure><p>我们启动Dokcer后，Docker会启动一个服务，即Docker守护进程（Docker Daemon），他会监听Docker客户端（Docker Client）的命令，当我们下达了<code>docker run</code>命令后，守护进程就会监听到，然后就会到<strong>镜像仓库</strong>（存储和管理镜像的平台，Docker官方维护了一个公共仓库 <code>Docker Hub</code>）寻找你所需要的镜像并拉去到本地</p><h3 id="命令解读（docker-run）"><a href="#命令解读（docker-run）" class="headerlink" title="命令解读（docker run）"></a>命令解读（docker run）</h3><ul><li><code>-d</code>：让容器后台运行</li><li><code>--name</code>：给容器命名</li><li><code>-e</code>：环境变量</li><li><code>-p</code>：将宿主机端口映射到容器内端口</li><li>名称结构  镜像名（repository）：版本号(TAG)如果未指定版本号，即默认最新版</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul><li><code>docker info</code>: 显示Docker系统信息，包括容器和镜像的数量、Docker使用的执行驱动和存储驱动等。</li><li><code>docker version</code>: 显示Docker版本信息，包括客户端和服务器端的版本号、API版本、Git commit等。</li></ul><h3 id="2-镜像管理"><a href="#2-镜像管理" class="headerlink" title="2. 镜像管理"></a>2. 镜像管理</h3><ul><li><code>docker images</code>: 列出本地主机上的所有镜像。</li><li><code>docker search [IMAGE_NAME]</code>: 从Docker Hub搜索镜像。</li><li><code>docker pull [IMAGE_NAME]</code>: 从Docker Hub或其他仓库下载镜像到本地。</li><li><code>docker rmi [IMAGE_ID]</code>: 删除本地的一个或多个镜像。</li><li><code>docker build</code>: 使用Dockerfile构建镜像。</li><li><code>docker tag [SOURCE_IMAGE] [TARGET_IMAGE]</code>: 标记本地镜像，将其归入某一仓库。</li><li><code>docker push [IMAGE_NAME]</code>: 将本地的镜像推送到Docker Hub或其他仓库。</li></ul><h3 id="3-容器管理"><a href="#3-容器管理" class="headerlink" title="3. 容器管理"></a>3. 容器管理</h3><ul><li><code>docker run</code>: 创建一个新的容器并运行一个命令。若本地没有指定镜像，则会到默认仓库中拉去该镜像</li><li><code>docker ps</code>: 列出当前正在运行的容器。</li><li><code>docker ps -a</code>: 列出所有容器，包括已经停止的容器。</li><li><code>docker stop [CONTAINER_ID]</code>: 停止一个或多个正在运行的容器。</li><li><code>docker start [CONTAINER_ID]</code>: 启动一个或多个已经停止的容器。</li><li><code>docker restart [CONTAINER_ID]</code>: 重启一个或多个容器。</li><li><code>docker rm [CONTAINER_ID]</code>: 删除一个或多个容器。</li><li><code>docker attach [CONTAINER_ID]</code>: 连接到正在运行中的容器。</li><li><code>docker exec -it [CONTAINER_ID] [COMMAND]</code>: 在运行的容器中执行命令。</li><li><code>docker logs [CONTAINER_ID]</code>: 获取容器的日志。</li><li><code>docker inspect [CONTAINER_ID]</code>: 查看容器的详细信息。</li><li><code>docker top [CONTAINER_ID]</code>: 查看容器中运行的进程。</li><li><code>docker cp [CONTAINER_ID]:[PATH_IN_CONTAINER] [PATH_IN_HOST]</code>: 从容器中复制文件到主机上。</li></ul><h3 id="4-系统信息和日志"><a href="#4-系统信息和日志" class="headerlink" title="4. 系统信息和日志"></a>4. 系统信息和日志</h3><ul><li><code>docker events</code>: 从服务器获取实时事件。</li><li><code>docker history [IMAGE_NAME]</code>: 显示一个镜像的历史。</li></ul><h2 id="数据卷挂载"><a href="#数据卷挂载" class="headerlink" title="数据卷挂载"></a>数据卷挂载</h2><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>数据卷是一个虚拟目录，他将宿主机目录映射到容器内目录，方便我们操作容器内文件，或者方便迁移容器内产生的数据</p><h3 id="如何挂在数据卷"><a href="#如何挂在数据卷" class="headerlink" title="如何挂在数据卷"></a>如何挂在数据卷</h3><ul><li><p>在创建容器时，利用<code>-v 数据卷名：容器内目录</code>完成挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name  nginx -p 80:80 -v html:/user/share/nginx/html nginx</span><br></pre></td></tr></table></figure></li><li><p>容器创建时，如果发现挂载的数据卷不存在，会自动创建</p></li></ul><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><ul><li><code>docker volume ls</code>：查看数据卷</li><li><code>docker volume rm</code>：删除数据卷</li><li><code>docker volume inspect</code>：查看数据卷详情</li><li><code>docker volume prune</code>：删除未使用数据卷</li></ul><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><h3 id="镜像的结构是什么"><a href="#镜像的结构是什么" class="headerlink" title="镜像的结构是什么"></a>镜像的结构是什么</h3><p>镜像中包含了应用程序所需要的运行环境，函数库，配置以及应用本身等各种文件，这些文件分层打包而成</p><h3 id="Dockerfile是做什么"><a href="#Dockerfile是做什么" class="headerlink" title="Dockerfile是做什么"></a>Dockerfile是做什么</h3><p>Dockerfile就是利用固定的指令来描述镜像的结构和构建过程，这样Docker才可以来构建镜像</p><h3 id="构建镜像的命令是什么"><a href="#构建镜像的命令是什么" class="headerlink" title="构建镜像的命令是什么"></a>构建镜像的命令是什么</h3><p><code>docker build -t 镜像名 Dockerfile目录</code></p><h2 id="容器网络互联"><a href="#容器网络互联" class="headerlink" title="容器网络互联"></a>容器网络互联</h2><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>docker network create</code></td><td align="center">创建一个网络</td></tr><tr><td align="center"><code>docker network ls</code></td><td align="center">查看所有网络</td></tr><tr><td align="center"><code>docker network rm</code></td><td align="center">删除指定网络</td></tr><tr><td align="center"><code>docker network prune</code></td><td align="center">清除未使用网络</td></tr><tr><td align="center"><code>docker network connect</code></td><td align="center">使指定容器连接加入某网络</td></tr><tr><td align="center"><code>docker network disconnect</code></td><td align="center">使指定容器连接离开某网络</td></tr><tr><td align="center"><code>docker network inspect</code></td><td align="center">查看网络详细信息</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux学习</title>
      <link href="/2024/05/19/linux%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/05/19/linux%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul><li><p>linux操作系统的目录结构</p><p>Linux只有一个顶级目录，称之为：根目录</p><p>Windows系统有多个顶级目录，即各个盘符</p></li><li><p>&#x2F;在Linux系统中表示</p><p>出现在开头的<code>/</code>表示根目录，出现在后面的<code>/</code>表示层级关系</p></li></ul><h2 id="Linux命令入门"><a href="#Linux命令入门" class="headerlink" title="Linux命令入门"></a>Linux命令入门</h2><h3 id="Linux命令基础"><a href="#Linux命令基础" class="headerlink" title="Linux命令基础"></a>Linux命令基础</h3><h4 id="什么是命令，命令行"><a href="#什么是命令，命令行" class="headerlink" title="什么是命令，命令行"></a>什么是命令，命令行</h4><ul><li>命令：即Linux操作指令，是系统内置的程序，可以以字符化的形式去使用</li><li>命令行：即Linux终端，可以提供字符化的操作页面供命令执行</li></ul><h4 id="Linux命令通用格式"><a href="#Linux命令通用格式" class="headerlink" title="Linux命令通用格式"></a>Linux命令通用格式</h4><p><code>command[-options][parameter]</code></p><ul><li>命令本体，即命令本身</li><li>可选选项，控制命令的行为细节</li><li>可选参数，控制命令的指向目标</li></ul><h4 id="ls命令入门"><a href="#ls命令入门" class="headerlink" title="ls命令入门"></a>ls命令入门</h4><ul><li>ls命令作用：在命令行中，以平埔的形式，展示当前工作目录（默认Home目录）下的内容</li><li>Home目录：每一个用户在Linux系统的专属目录：默认在&#x2F;home&#x2F;用户名</li><li>当前工作目录：Linux命令行在执行命令的时候，需要一个工作目录，打开命令行程序（终端）默认设置目录在Home目录</li></ul><h4 id="ls命令的参数和选项"><a href="#ls命令的参数和选项" class="headerlink" title="ls命令的参数和选项"></a>ls命令的参数和选项</h4><ul><li><p>ls命令参数的作用：可以查看指定文件夹的内容，如果不给定参数，则查看当前工作目录下的内容</p></li><li><p>ls命令的选项：</p><p>（1）-a选项，可以展示出隐藏的内容</p><p>（2）-l选项，以列表的形式展示内容，并展示更多细节</p><p>（3）-h选项，需要和-l选项搭配使用，可以显示文件的大小单位</p></li><li><p>命令的选项组合使用</p><p>命令的选项是可以组合的，比如<code>ls -lah</code>，等同于<code>ls -a -l -h</code></p></li></ul><h3 id="目录切换相关命令"><a href="#目录切换相关命令" class="headerlink" title="目录切换相关命令"></a>目录切换相关命令</h3><h4 id="cd命令（切换工作目录）"><a href="#cd命令（切换工作目录）" class="headerlink" title="cd命令（切换工作目录）"></a>cd命令（切换工作目录）</h4><p>用来切换当前的工作目录，语法是</p><p><code>cd [Linux路径]</code></p><ul><li>没有选项，只有参数，表示目标路径</li><li>使用参数，切换到目标路径</li><li>不使用参数，切换工作目录到当前用户的HOME</li></ul><h4 id="pwd命令（输出工作目录）"><a href="#pwd命令（输出工作目录）" class="headerlink" title="pwd命令（输出工作目录）"></a>pwd命令（输出工作目录）</h4><ul><li>pwd命令：没有选项，没有参数，直接使用即可</li><li>作用：输出当前的工作目录</li></ul><h4 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h4><ul><li>绝对路径：以根目录为起点，描述路径的方式，路径以<code>/</code>开头</li><li>相对路径：以当前目录做起点，描述路径的方式，路径不需以<code>/</code>开头</li></ul><h4 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符"></a>特殊路径符</h4><ul><li><code>.</code>表示当前目录</li><li><code>..</code>表示上一级目录</li><li><code>~</code>表示用户的HOME目录</li></ul><h3 id="创建目录命令"><a href="#创建目录命令" class="headerlink" title="创建目录命令"></a>创建目录命令</h3><h4 id="mkdir命令（创建目录）"><a href="#mkdir命令（创建目录）" class="headerlink" title="mkdir命令（创建目录）"></a>mkdir命令（创建目录）</h4><ul><li>mkdir用以创建新的目录</li><li>语法：<code>mkdir  [-p]  Linux路径</code></li><li>参数必填，表示要创建的目录的路径，相对，绝对路径均可使用</li><li>p选项可选，表示自动创建不存在的父目录，适用于创建连续多层级的目录</li></ul><h3 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h3><h4 id="touch命令（创建文件）"><a href="#touch命令（创建文件）" class="headerlink" title="touch命令（创建文件）"></a>touch命令（创建文件）</h4><ul><li>用于创建一个新的文件</li><li>语法 <code>touch Linux路径</code></li><li>参数必填，表示要创建文件的路径</li></ul><h4 id="cat命令（查看文件内容）"><a href="#cat命令（查看文件内容）" class="headerlink" title="cat命令（查看文件内容）"></a>cat命令（查看文件内容）</h4><ul><li>用于查看文件内容</li><li>语法 <code>cat Linux路径</code></li><li>参数必填，表示要查看文件的路径</li></ul><h4 id="more命令（翻页查看文件内容）"><a href="#more命令（翻页查看文件内容）" class="headerlink" title="more命令（翻页查看文件内容）"></a>more命令（翻页查看文件内容）</h4><ul><li>用于查看文件内容，可翻页查看</li><li>语法 <code>more Linux路径</code></li><li>参数必填，表示要查看文件的路径</li><li>使用空格翻页，使用p退出查看</li></ul><h4 id="cp命令（复制文件-文件夹）"><a href="#cp命令（复制文件-文件夹）" class="headerlink" title="cp命令（复制文件&#x2F;文件夹）"></a>cp命令（复制文件&#x2F;文件夹）</h4><ul><li>用于复制文件或文件夹</li><li>语法 <code>cp [-r] 参数1 参数2</code></li><li>参数1和参数2分别表示被复制的文件或文件夹和复制要去的地方</li><li>选项可填，带上表示复制的是一个文件夹</li></ul><h4 id="mv命令（移动文件）"><a href="#mv命令（移动文件）" class="headerlink" title="mv命令（移动文件）"></a>mv命令（移动文件）</h4><ul><li>用于移动文件</li><li>语法 <code>mv 参数1 参数2</code></li><li>参数1表示被移动的文件或文件夹，参数2表示移动要去的地方，如果不存在则对参数1进行改名</li></ul><h4 id="rm命令（删除文件-文件夹）"><a href="#rm命令（删除文件-文件夹）" class="headerlink" title="rm命令（删除文件&#x2F;文件夹）"></a>rm命令（删除文件&#x2F;文件夹）</h4><ul><li>用于删除文件或文件夹</li><li>语法 <code>rm [-r -f] 参数1 参数2 ......</code></li><li>-r选项，可选，表示文件夹删除    -f，可选，表示强制删除（一般用于root用户）</li><li>参数表示被删除的文件或文件夹路径，可支持批量删，也支持通配符*，可用于模糊匹配</li></ul><h3 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h3><h4 id="which命令（查找命令）"><a href="#which命令（查找命令）" class="headerlink" title="which命令（查找命令）"></a>which命令（查找命令）</h4><ul><li>查找命令的程序文件</li><li>语法 <code>which 要查找的命令</code></li></ul><h4 id="find命令（查找文件）"><a href="#find命令（查找文件）" class="headerlink" title="find命令（查找文件）"></a>find命令（查找文件）</h4><p>（1）按名称查找</p><p>语法：<code>find 起始路径 -name &quot;被查找文件名&quot;</code></p><ul><li>支持通配符<code>*</code></li></ul><p>(2)按文件大小查找</p><p>语法：<code>find 起始路径 -size +/-  n[KMG]</code></p><ul><li>+&#x2F;-代表大于或小于</li><li>n代表数字</li><li>[KMG]是大小的单位</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find /user -size + 100 M</span><br><span class="line"><span class="comment">#/user目录内大于100M的文件</span></span><br></pre></td></tr></table></figure><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><h4 id="grep命令（过滤文件行）"><a href="#grep命令（过滤文件行）" class="headerlink" title="grep命令（过滤文件行）"></a>grep命令（过滤文件行）</h4><ul><li>从文件中通过关键词过滤文件行</li><li>语法：<code>grep  [-n] 关键字  文件路径</code></li><li>选项-n，可选，表示在结果中匹配的行的行号</li><li>关键字必填，表示要过滤的关键字，建议用” “包围起来</li><li>文件路径必填，表示要过滤的内容的文件路径，可通过管道符输入。</li></ul><h4 id="WC命令（统计文件数据）"><a href="#WC命令（统计文件数据）" class="headerlink" title="WC命令（统计文件数据）"></a>WC命令（统计文件数据）</h4><ul><li>命令统计文件的行数，单词数，字节数，字符数</li><li>语法：<code>wc [-c -m -l -w] 文件路径</code></li><li>不带选项默认统计行数，单词数，字节数</li><li>-c字节数   -m字符数   -l行数   -w单词数</li><li>参数，被统计的文件路径，可通过管道符输入</li></ul><h4 id="管道符"><a href="#管道符" class="headerlink" title="管道符|"></a>管道符<code>|</code></h4><p>将管道左边的结果作为右边的输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> text.txt | grep hello | <span class="built_in">wc</span> -l</span><br><span class="line"><span class="comment">#统计text.txt中带有hello关键字的有几行</span></span><br></pre></td></tr></table></figure><h4 id="echo命令（输出内容）"><a href="#echo命令（输出内容）" class="headerlink" title="echo命令（输出内容）"></a>echo命令（输出内容）</h4><ul><li>可以使用echo命令在命令行输出指定内容</li><li>语法：<code>echo 输出内容</code></li><li>无需选项，只需一个参数，表示要输出的内容，可用” “包围</li></ul><h4 id="反引号符"><a href="#反引号符" class="headerlink" title="&#96;&#96; &#96;反引号符"></a>&#96;&#96; &#96;反引号符</h4><p>被&#96;&#96; &#96;包围的内容，会被当做命令执行，而非普通字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">pwd</span>`</span><br><span class="line"><span class="comment">#不会输出`pwd`，而会输出当前工作目录</span></span><br></pre></td></tr></table></figure><h4 id="重定向符（写入结果）"><a href="#重定向符（写入结果）" class="headerlink" title="重定向符（写入结果）"></a>重定向符（写入结果）</h4><ul><li><code>&gt;</code>，将左侧命令的结果，覆盖写入符号右边的指定文件中</li><li><code>&gt;&gt;</code>，将左侧命令的结果，追加写入符号右边的指定文件中</li></ul><h4 id="tail命令（查看尾部内容）"><a href="#tail命令（查看尾部内容）" class="headerlink" title="tail命令（查看尾部内容）"></a>tail命令（查看尾部内容）</h4><ul><li>查看文件尾部的内容，并可以持续追踪</li><li>语法：<code>tail [-f  -num] Linux路径</code></li><li><code>-f</code>:持续追踪，<code>-num</code>，查看尾部多少行，默认查看尾部10行</li></ul><h3 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>vi\vim编辑器，就是命令行模式下的文本编辑器，用来编辑文件</li><li>vim是vi的升级版，一般用vim即可，包含vi的全部功能</li></ul><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><p><code>vi 文件路径</code>    <code>vim 文件路径</code></p><h4 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h4><ul><li>命令模式：默认模式，可以通过键盘快捷键控制文件内容</li><li>输入模式：通过命令模式输入<code>i</code>进入，可以输入内容进行编辑，按<code>esc</code>退回命令模式</li><li>底线命令模式：通过命令模式进入，可以对文件进行保存，关闭操作，输入<code>wq</code>退出</li></ul><h2 id="Linux用户和权限"><a href="#Linux用户和权限" class="headerlink" title="Linux用户和权限"></a>Linux用户和权限</h2><h3 id="Linux的root用户"><a href="#Linux的root用户" class="headerlink" title="Linux的root用户"></a>Linux的root用户</h3><p>Linux系统的超级用户管理员是：root</p><h4 id="su命令（切换命令）"><a href="#su命令（切换命令）" class="headerlink" title="su命令（切换命令）"></a>su命令（切换命令）</h4><ul><li>可以切换用户，语法：<code>su  [-]  [用户名]</code></li><li><code>-</code>表示切换后带上环境变量，建议带上</li><li>用户可以省略，省略默认切换到root</li></ul><h4 id="sudo命令（增加权限）"><a href="#sudo命令（增加权限）" class="headerlink" title="sudo命令（增加权限）"></a>sudo命令（增加权限）</h4><ul><li><p>可以让一条普通命令带有root权限，语法：<code>sudo  其他命令</code></p></li><li><p>需要以root用户执行<code>visudo</code>命令，增加相关的配置方法即可让普通用户有<code>sudo</code>命令的执行权限</p><p>在该文件的最后一行加入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名  ALL=(ALL)    NOPASSWD: ALL</span><br></pre></td></tr></table></figure></li></ul><h3 id="用户-用户组管理"><a href="#用户-用户组管理" class="headerlink" title="用户 用户组管理"></a>用户 用户组管理</h3><h4 id="Linux用户管理模式"><a href="#Linux用户管理模式" class="headerlink" title="Linux用户管理模式"></a>Linux用户管理模式</h4><ul><li>Linux可以支持多用户，多用户组，用户加入多个组</li><li>Linux权限管控的单元是用户级别和用户组级别</li></ul><h4 id="用户-用户组相关命令"><a href="#用户-用户组相关命令" class="headerlink" title="用户  用户组相关命令"></a>用户  用户组相关命令</h4><ul><li><code>groupadd</code>添加用户组，<code>groupdel</code>删除用户组</li><li><code>useradd</code>添加用户，<code>userdel</code>删除用户</li><li><code>usermod -aG 用户组 用户名</code>修改用户组，将指定用户加入到用户组，<code>id</code>命令查看用户信息</li><li><code>getent password</code>查看系统全部用户信息</li><li><code>getent group</code>查看系统全部组信息</li></ul><h3 id="查看权限控制"><a href="#查看权限控制" class="headerlink" title="查看权限控制"></a>查看权限控制</h3><h4 id="ls-l列出的权限信息"><a href="#ls-l列出的权限信息" class="headerlink" title="ls -l列出的权限信息"></a>ls -l列出的权限信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x. 2 yh yh 6 5月  19  02:34 Desktop</span><br><span class="line"><span class="comment">#1            #2 #3</span></span><br></pre></td></tr></table></figure><ul><li>序号1，表示文件，文件夹的控制信息</li><li>序号2，表示文件，文件夹的所属用户</li><li>序号3，表示文件，文件夹所属用户组</li></ul><h4 id="权限细节"><a href="#权限细节" class="headerlink" title="权限细节"></a>权限细节</h4><table><thead><tr><th>文件类型（1）</th><th>所有者权限（2-4）</th><th>同组用户权限（5-7）</th><th>其他用户权限（8-10）</th></tr></thead><tbody><tr><td><code>-</code>或<code>d</code>或<code>l</code></td><td>(<code>r</code>或<code>-</code>)</td><td>(<code>w</code>或<code>-</code>)</td><td>(<code>x</code>或<code>-</code>)</td></tr></tbody></table><p>文件类型：<code>-</code>表示文件，<code>d</code>表示文件夹，<code>l</code>表示软连接</p><h4 id="rwx分别代表什么"><a href="#rwx分别代表什么" class="headerlink" title="rwx分别代表什么"></a>rwx分别代表什么</h4><ul><li><code>r</code>表示可以查看内容</li><li><code>w</code>表示可以修改此文件，针对文件夹即可以创建，修改，删除等操作</li><li><code>x</code>表示可以将文件作为程序执行，针对文件夹，则表示可以将工作目录更改到此文件夹，即<code>cd</code>进入</li><li><code>-</code>即代表不包含该类权限</li></ul><h3 id="修改权限控制-chmod"><a href="#修改权限控制-chmod" class="headerlink" title="修改权限控制-chmod"></a>修改权限控制-chmod</h3><h4 id="chmod命令（修改文件-文件夹权限）"><a href="#chmod命令（修改文件-文件夹权限）" class="headerlink" title="chmod命令（修改文件&#x2F;文件夹权限）"></a>chmod命令（修改文件&#x2F;文件夹权限）</h4><ul><li><p>修改文件，文件夹的权限细节</p></li><li><p>只能是文件，文件夹的所属用户或root有权修改</p></li><li><p>语法：<code>chmod [-R] 权限  文件或文件夹</code></p></li><li><p>选项<code>-R</code>，对文件夹内的内容应用同样的规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R u=rwx,g=rx,o=x hello.txt</span><br><span class="line"><span class="comment">#-rwxr-x--x</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="权限的数字序号"><a href="#权限的数字序号" class="headerlink" title="权限的数字序号"></a>权限的数字序号</h4><ul><li><p><code>r</code>代表4，<code>w</code>代表2，<code>x</code>代表1</p></li><li><p>通过相应的数字整合即可得到相应权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R 761 hello.txt</span><br><span class="line"><span class="comment">#-rwxrw---x</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="修改权限控制-chown"><a href="#修改权限控制-chown" class="headerlink" title="修改权限控制-chown"></a>修改权限控制-chown</h3><h4 id="chown命令（修改文件-文件夹所属用户）"><a href="#chown命令（修改文件-文件夹所属用户）" class="headerlink" title="chown命令（修改文件&#x2F;文件夹所属用户）"></a>chown命令（修改文件&#x2F;文件夹所属用户）</h4><ul><li><p>修改文件，文件夹的所属用户和用户组</p></li><li><p>此命令只适用于<code>root</code>用户</p></li><li><p>语法：<code>chown [-R] [用户] [:] [用户组] 文件或文件夹</code></p></li><li><p>选项<code>-R</code>，对文件夹内的内容应用同样的规则</p></li><li><p>选项用户和用户组分别对应修改所属用户和用户组</p></li><li><p><code>:</code>用于分隔用户和用户组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> root hello.txt</span><br><span class="line"><span class="comment">#将文件的用户修改为root</span></span><br><span class="line"><span class="built_in">chown</span> :root hello.txt</span><br><span class="line"><span class="comment">#将文件的用户组修改为root</span></span><br><span class="line"><span class="built_in">chown</span> root:root hello.txt</span><br><span class="line"><span class="comment">#将文件的用户和用户组都修改为root</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Linux实用操作"><a href="#Linux实用操作" class="headerlink" title="Linux实用操作"></a>Linux实用操作</h2><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><ul><li><code>ctrl+c</code>强制停止</li><li><code>ctrl+d</code>退出登录</li><li><code>history</code>查看历史命令</li><li><code>ctrl+l</code>清屏</li><li><code>ctrl+a/e</code>光标移动到命令开始或结束   <code>ctrl+&lt;- | -&gt;</code>左右跳单词</li></ul><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><h4 id="Centos系统"><a href="#Centos系统" class="headerlink" title="Centos系统"></a>Centos系统</h4><ul><li>语法：<code>yum [-y] [install | remove | search] 软件名称 </code> </li><li>选项<code>-y</code>，自动确认，无需手动确认安装和卸载过程</li><li>该操作需要root权限</li></ul><h4 id="Ubuntu系统"><a href="#Ubuntu系统" class="headerlink" title="Ubuntu系统"></a>Ubuntu系统</h4><ul><li>语法：<code>apt [-y] [install | remove | search] 软件名称</code></li><li>选项与Centos系统相同</li></ul><h3 id="控制软件进程"><a href="#控制软件进程" class="headerlink" title="控制软件进程"></a>控制软件进程</h3><h4 id="systemctl命令（控制软件启动等）"><a href="#systemctl命令（控制软件启动等）" class="headerlink" title="systemctl命令（控制软件启动等）"></a>systemctl命令（控制软件启动等）</h4><p>可以控制软件的启动，关闭和自启动</p><ul><li>系统内置服务均可被<code>systemctl</code>控制</li><li>第三方软件，如果自动注册了，则可以被<code>systemctl</code>控制</li><li>如果没有自动注册，则可以手动注册</li><li>语法：<code>systemctl start | stop | status | enable | disable 服务名</code></li><li><code>start/stop</code>启动&#x2F;停止    <code>status</code>状态   <code>enable/disable</code>开启自启&#x2F;关闭开机自启</li></ul><h3 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>可以将文件，文件夹链接到其他位置，链接只是一个指向，并不是物理移动，类似于Windows系统的快捷方式</p><h4 id="使用用法"><a href="#使用用法" class="headerlink" title="使用用法"></a>使用用法</h4><p>语法：<code>ln -s 参数1 参数2</code></p><ul><li>-s选项，创建软连接</li><li>参数1：被链接的文件，文件夹</li><li>参数2：要连接去的目的地</li></ul><h3 id="日期和时区"><a href="#日期和时区" class="headerlink" title="日期和时区"></a>日期和时区</h3><h4 id="date命令（查看时间）"><a href="#date命令（查看时间）" class="headerlink" title="date命令（查看时间）"></a>date命令（查看时间）</h4><p>可以查看时间，并可以格式化显示形式以及做日期计算</p><p>语法：&#96;date [-d] [+格式化字符串]</p><p>%Y年   %y 年份后两位数字  %m 月份  %d 日   %H 小时  %M 分钟  %S 秒</p><h4 id="修改Linux时区"><a href="#修改Linux时区" class="headerlink" title="修改Linux时区"></a>修改Linux时区</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f /etc/localtime <span class="comment">#删除该文件</span></span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/share/zoneInfo/Asia/Shanghai /etc/localtime  <span class="comment">#创建软连接到该文件</span></span><br></pre></td></tr></table></figure><h4 id="ntp"><a href="#ntp" class="headerlink" title="ntp"></a>ntp</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ntp  <span class="comment">#下载该软件</span></span><br></pre></td></tr></table></figure><p>可以自动联网校准时间，也可以通过<code>ntpdate -u ntp.aliyun.com</code>手动校准时间</p><h3 id="IP地址和主机名"><a href="#IP地址和主机名" class="headerlink" title="IP地址和主机名"></a>IP地址和主机名</h3><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>IP地址是联网计算机的网络地址，用于在网络中进行定位  特殊IP：127.0.0.1表本机   0.0.0.0也可表示本机，也可在一些白名单中表示任意IP</p><h4 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h4><p>主机名就是主机的名称，用于标识一个计算机</p><h4 id="域名解析（主机名映射）"><a href="#域名解析（主机名映射）" class="headerlink" title="域名解析（主机名映射）"></a>域名解析（主机名映射）</h4><p>通过主机名找到对应的IP地址，即主机名映射</p><p>先从系统的本地记录中查找，如未找到，再去联网公开的DNS服务器去找</p><h3 id="网络请求和下载"><a href="#网络请求和下载" class="headerlink" title="网络请求和下载"></a>网络请求和下载</h3><h4 id="Ping命令（测试服务器是否可联通）"><a href="#Ping命令（测试服务器是否可联通）" class="headerlink" title="Ping命令（测试服务器是否可联通）"></a>Ping命令（测试服务器是否可联通）</h4><ul><li><p>语法：&#96;ping [-c num] ip或主机名</p></li><li><p>选项c，测试的次数   </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 3 baidu.com</span><br></pre></td></tr></table></figure></li></ul><h4 id="wget命令（网络文件下载）"><a href="#wget命令（网络文件下载）" class="headerlink" title="wget命令（网络文件下载）"></a>wget命令（网络文件下载）</h4><ul><li>语法：<code>wget [-b] url</code></li><li>选项-b，后台下载</li></ul><h4 id="curl命令（网络请求）"><a href="#curl命令（网络请求）" class="headerlink" title="curl命令（网络请求）"></a>curl命令（网络请求）</h4><ul><li>语法：<code>curl [-O] url</code></li><li>选项-O，用于下载使用</li></ul><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>IP只能确认计算机，通过端口才能锁定要交互的程序</p><h4 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h4><ul><li>公认端口：1-1023，用于系统内置或常用知名软件绑定使用</li><li>注册端口：1024-49151，用于松散绑定使用（用户自定义）</li><li>动态端口：49152-65535，用于临时使用（多用于出口）</li></ul><h4 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h4><ul><li><code>nmap IP地址</code>，查看指定IP对外暴露的端口</li><li><code>netstat -anp | grap 端口号</code>，查看本机指定端口号的占用情况</li></ul><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>进程是指程序在操作系统内运行后被注册为系统内的一个进程，并拥有独立的进程ID</p><ul><li><code>ps-ef</code>命令（查看进程信息）</li><li><code>ps -ef | grep 关键字</code>过滤指定关键字的进程</li><li><code>kill [-9] 进程号</code> 关闭指定进程，-9表示强制关闭</li></ul><h3 id="主机状态监控"><a href="#主机状态监控" class="headerlink" title="主机状态监控"></a>主机状态监控</h3><h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><ul><li>类似于windows的任务管理器</li><li>查看CPU，内存，进程的信息</li></ul><h4 id="df命令（查看磁盘使用率）"><a href="#df命令（查看磁盘使用率）" class="headerlink" title="df命令（查看磁盘使用率）"></a>df命令（查看磁盘使用率）</h4><h4 id="iostat命令（查看磁盘速率）"><a href="#iostat命令（查看磁盘速率）" class="headerlink" title="iostat命令（查看磁盘速率）"></a>iostat命令（查看磁盘速率）</h4><h4 id="sar-n-DEV-命令（查看网络情况）"><a href="#sar-n-DEV-命令（查看网络情况）" class="headerlink" title="sar -n DEV 命令（查看网络情况）"></a>sar -n DEV 命令（查看网络情况）</h4><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>环境变量是一组信息记录，类型是key-value，用于操作系统运行时记录关键信息</p><h4 id="env命令"><a href="#env命令" class="headerlink" title="env命令"></a>env命令</h4><p>可以查看当前系统配置的环境变量信息，通过<code>$</code>符可以取出环境变量的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;PATH&#125;</span></span><br><span class="line"><span class="comment">#打印出PATH这个环境变量的值</span></span><br></pre></td></tr></table></figure><h4 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a>PATH</h4><p>环境变量PATH会记录一组目录，目录之间用:隔开。这里记录的是命令的搜索路径，当执行命令会从记录中记录的目录中挨个搜索要执行的命令并执行。可以通过修改这个项目的值，加入自定义的命令搜索路径</p><p>如<code>export PATH=$PATH:自定义路径</code></p><h4 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h4><ul><li><p>临时生效：export 名称&#x3D;值</p></li><li><p>永久生效</p><p>针对用户：<code>~/bashrc文件中配置</code></p><p>针对全局：<code>/etc/profile 文件中配置</code></p><p>配置完成，通过<code>source</code>命令立刻生效</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis-plus</title>
      <link href="/2024/05/18/Mybatis-plus/"/>
      <url>/2024/05/18/Mybatis-plus/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>MyBatis-Plus</code> 是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。它提供了很多实用的功能，使得开发者在使用 MyBatis 时能够更加方便和高效。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul><li><p>@TableName: 指定表名及全局配置</p></li><li><p>@TableId：指定Id字段及相关配置</p><p>IdType的类型：</p><p>(1)AUTO：自增长，由数据库生成id    </p><p>(2) ASSIGN_ID：通过雪花算法，由mp生成id    </p><p>(3)INPUT：通过用户输入id</p></li><li><p>@TableFiled：指定普通字段及相关配置</p><p>使用场景</p><ul><li>成员变量与数据库名称不一致</li><li>成员变量以is开头，且是布尔值</li><li>成员变量与数据库关键词冲突</li><li>成员变量不是数据库字段</li></ul></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="comment">#别名扫描包</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">&quot;classpath*:/mapper/**/*.xml&quot;</span> <span class="comment">#mapper.xml文件地址</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">cache-enabled:</span> <span class="literal">false</span> <span class="comment">#是否开启二级缓存</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">ASSIGN_ID</span> <span class="comment">#id为雪花算法生成</span></span><br><span class="line">      <span class="attr">update-strategy:</span> <span class="string">not_null</span> <span class="comment">#更新策略：只更新非空字段</span></span><br></pre></td></tr></table></figure><h3 id="条件构造器用法"><a href="#条件构造器用法" class="headerlink" title="条件构造器用法"></a>条件构造器用法</h3><ul><li>QueryWrapper和LambdaQueryWrapper通常用来构建select，delete，update的where条件部分</li><li>UpdateWrapper和LambdaUpdateWrapper通常只有在set语句比较特殊时才使用</li><li>尽量使用LambdaQueryWrapper和LambdaUpdateWrapper，避免硬编码(例User::getId)</li></ul><h3 id="自定义sql"><a href="#自定义sql" class="headerlink" title="自定义sql"></a>自定义sql</h3><p>由于mp擅长的事where条件的编写，但不擅长select，set等处的编写，此时若在构造器处去拼相应的代码，那么就需要在业务层去构建sql语句，这显然不符合大多数企业的开发规范，此时则需要自定义sql</p><ul><li><p>基于Wrapper构建Where条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="type">long</span>&gt; ids = List.of(<span class="number">1L</span>,<span class="number">2L</span>,<span class="number">4L</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="comment">//构建条件</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;().in(User::getId,ids);</span><br><span class="line"><span class="comment">//自定义sql方法调用</span></span><br><span class="line">usermapper.updateBalanceByIds(wrapper,amount);</span><br></pre></td></tr></table></figure></li><li><p>在mapper方法参数中用param注解声明wrapper变量名称，必须是ew</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update(&quot;update tb_user set balance = balance-#&#123;amount&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">updateBalanceByIds</span><span class="params">(<span class="meta">@param(&quot;ew&quot;)</span> LambdaQueryWrapper&lt;User&gt; wrapper,<span class="meta">@param(&quot;amount&quot;)</span> <span class="type">int</span> amount)</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="MP的Service接口使用"><a href="#MP的Service接口使用" class="headerlink" title="MP的Service接口使用"></a>MP的Service接口使用</h3><ul><li><p>自定义Service接口继承IService接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt;&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义service实现类，实现自定义接口并继承ServiceImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper,User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h3><p>在实际业务中，用户删除的一些数据并不是真的删除了，而是采用逻辑删除，例如，用户将购物车中的商品取消，但此时并不是真的删除了这一条数据，因为这些数据对于后期的数据统计非常重要，所以实际开发中，通常会使用一个标记来确定此商品是否真的被删除</p><p>MP提供了逻辑删除的功能，无需改变方法调用的方式，而是在底层自动帮我们修改CRUD语句，我们要做的就是在yml文件中配置逻辑删除的字段名称和值即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">   <span class="attr">db-config:</span></span><br><span class="line">     <span class="attr">logic-delete-filed:</span> <span class="string">deleted</span> <span class="comment">#全局删除的实体字段名，字段类型可以是boolean,integer</span></span><br><span class="line">     <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment">#逻辑已删除值（默认为1）</span></span><br><span class="line">     <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment">#逻辑未删除值（默认为0）</span></span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>逻辑删除的问题</p><ul><li>会导致数据库表垃圾数据越来越多，影响查询效率</li><li>SQL中全部需要对逻辑字段做判断，影响查询效率</li></ul><p>因此，如果数据不能删除，可以采用将数据迁移到其他表的方法</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端相关笔记</title>
      <link href="/2024/05/13/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/05/13/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="路由器："><a href="#路由器：" class="headerlink" title="路由器："></a>路由器：</h2><ul><li><p>路由组成</p><ul><li><code>VueRouter</code>：路由器，根据路由请求在路由视图上动态渲染对应组件。</li><li><code>&lt;router-link&gt;</code>：路由链接组件，浏览器会解析成超链接。</li><li><code>&lt;router-view&gt;</code>：路由器组件，用来展示与路由路径匹配的路由组件，可以将其类比为页面中的占位。</li></ul></li><li><p>相关流程</p><p>点击<code>&lt;router-link&gt;</code>发出路由请求到VueRouter，VueRouter根据路由路径的不同去渲染对应的组件，渲染到<code>&lt;router-view&gt;</code>的这个位置</p></li></ul><h3 id="安装路由"><a href="#安装路由" class="headerlink" title="安装路由"></a>安装路由</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router@3.5.1</span><br></pre></td></tr></table></figure><h3 id="router代码"><a href="#router代码" class="headerlink" title="router代码"></a>router代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Manage&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>( <span class="string">&#x27;../views/Manage.vue&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,<span class="comment">//组件路径</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">    <span class="comment">// route level code-splitting</span></span><br><span class="line">    <span class="comment">// this generates a separate chunk (about.[hash].js) for this route</span></span><br><span class="line">    <span class="comment">// which is lazy-loaded when the route is visited.</span></span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../views/AboutView.vue&#x27;</span>),<span class="comment">//组件所在位置</span></span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;子路由路径&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: <span class="string">&#x27;子路由组件&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">base</span>: process.<span class="property">env</span>.<span class="property">BASE_URL</span>,</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>mode</code> 选项定义了路由的模式。Vue Router 提供了两种模式：</p><ul><li>* <code>&#39;hash&#39;</code>：这是默认模式。在这种模式下，URL 会包含一个 <code>#</code> 符号，如 <code>http://example.com/#/about</code>。这种方式的好处是它对服务器没有特殊的要求，因为所有的 URL 都会发送到同一个 HTML 文件（通常是 <code>index.html</code>），然后由 Vue Router 接管。</li></ul><ul><li><code>&#39;history&#39;</code>：在这种模式下，URL 会看起来像正常的 URL，没有 <code>#</code> 符号，如 <code>http://example.com/about</code>。但是，为了正常工作，服务器需要配置以支持这种方式。当访问这样的 URL 时，服务器需要返回与 <code>index.html</code> 相同的 HTML 文件，然后由 Vue Router 接管并显示正确的视图。</li></ul><h2 id="Vuex介绍"><a href="#Vuex介绍" class="headerlink" title="Vuex介绍"></a>Vuex介绍</h2><ul><li><p>vuex是一个专门为vue.js应用程序开发的状态管理库</p></li><li><p>vuex可以在多个组件内共享数据，并且共享的数据时响应式的，及数据的变更能及时渲染到模板</p></li><li><p>vuex采用集中式存储所有组件的状态，更易管理，更规范</p></li></ul><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>ajax是一种异步无刷新技术</p><ul><li>异步：无需等待服务器返回结果，便可以执行其他程序</li><li>无刷新：做了一些操作后，页面不会刷新，依然停留在当前位置</li></ul><h3 id="同步异步对比"><a href="#同步异步对比" class="headerlink" title="同步异步对比"></a>同步异步对比</h3><p>在传统的Web应用中，当浏览器向服务器发送请求时，浏览器会等待服务器的响应，同时整个页面会被“锁定”，用户无法进行其他操作，直到服务器响应返回并处理完毕，页面才会重新“解锁”。这种方式被称为同步</p><p>在使用Ajax技术时，浏览器向服务器发送请求后，<strong>不会等待服务器的响应</strong>，而是立即返回并继续执行后续的代码。同时，浏览器会设置一个回调函数（Callback Function）来处理服务器的响应。当服务器响应返回时，浏览器会调用这个回调函数来处理响应数据，而不会阻塞用户的其他操作。这就是异步处理的方式。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在搜索引擎中，会有自动补全功能，每输入一个或几个字符，浏览器会发送一个ajax请求到服务器获取相关联想数据，如果是非异步请求，则发送请求的这一段时间，用户无法进行其他操作，会大大降低用户体验，反之，使用异步，<strong>发送请求后，浏览器不会等待服务器的响应</strong>，而是立即返回并继续执行后续的代码（如允许用户继续输入或执行其他操作）。其中的无刷新技术也可以在浏览器接到响应后不刷新整个页面，而是使用js结合DOM操作动态的将相关数据显示出来。</p><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><p>由于原生ajax过于繁杂，所以应用较少，这里介绍使用axios包装ajax请求的示例</p><h4 id="安装-axios"><a href="#安装-axios" class="headerlink" title="安装 axios"></a>安装 axios</h4><p>如果你还没有安装 <code>axios</code>，你可以使用 npm 或 yarn 来安装它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install axios  </span><br><span class="line"><span class="comment"># 或者  </span></span><br><span class="line">yarn add axios</span><br></pre></td></tr></table></figure><h4 id="使用-axios-发送-GET-请求"><a href="#使用-axios-发送-GET-请求" class="headerlink" title="使用 axios 发送 GET 请求"></a>使用 axios 发送 GET 请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 axios  </span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 发送 GET 请求到 API 地址  </span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>)  </span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;  </span><br><span class="line">    <span class="comment">// 请求成功时，处理响应数据  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);  </span><br><span class="line">  &#125;)  </span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;  </span><br><span class="line">    <span class="comment">// 请求失败时，处理错误  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);  </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="使用-axios-发送-POST-请求"><a href="#使用-axios-发送-POST-请求" class="headerlink" title="使用 axios 发送 POST 请求"></a>使用 axios 发送 POST 请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 axios  </span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 发送 POST 请求到 API 地址，并携带一些数据  </span></span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;https://api.example.com/submit&#x27;</span>, &#123;  </span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,  </span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span>  </span><br><span class="line">  &#125;)  </span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;  </span><br><span class="line">    <span class="comment">// 请求成功时，处理响应数据  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);  </span><br><span class="line">  &#125;)  </span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;  </span><br><span class="line">    <span class="comment">// 请求失败时，处理错误  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);  </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="使用-async-await-简化代码"><a href="#使用-async-await-简化代码" class="headerlink" title="使用 async&#x2F;await 简化代码"></a>使用 async&#x2F;await 简化代码</h4><p>如果你正在使用支持 <code>async/await</code> 的环境（如较新版本的 JavaScript 或 TypeScript），你可以进一步简化你的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 axios  </span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="comment">// 使用 async/await 发送 GET 请求  </span></span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>);  </span><br><span class="line">    <span class="comment">// 请求成功时，直接处理响应数据  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);  </span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;  </span><br><span class="line">    <span class="comment">// 请求失败时，处理错误  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 调用函数  </span></span><br><span class="line"><span class="title function_">fetchData</span>();</span><br></pre></td></tr></table></figure><p>使用 <code>axios</code> 可以让你更加专注于处理请求和响应数据，而不是编写复杂的错误处理和异步代码</p><h2 id="typeScript介绍"><a href="#typeScript介绍" class="headerlink" title="typeScript介绍"></a>typeScript介绍</h2><ul><li><p>为js的超集，js有的他都有，添加了类型补充</p><p>添加类型补充的好处</p><ul><li>TS属于静态类型编程语言，JS属于动态类型编程语言</li><li>静态类在编译期做类型检查，动态类在执行期做类型检查</li><li>则TS可以更早地发现问题</li></ul></li></ul><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>promise是JS中进行异步编程的新解决方案，旧方案是单纯的使用回调函数</p><ul><li>从语法上来看：promise是一个构造函数</li><li>从功能上来看：promise对象用来封装一个异步操作并可以获取其成功&#x2F;失败的结果值</li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><h4 id="指定回调函数的方式更加灵活"><a href="#指定回调函数的方式更加灵活" class="headerlink" title="指定回调函数的方式更加灵活"></a>指定回调函数的方式更加灵活</h4><ul><li>旧的：必须在启动异步任务前指定</li><li>promise：启动异步任务 &#x3D;&gt; 返回promise对象 &#x3D;&gt; 给promise对象绑定回调函数（甚至可以在异步任务结束后指定&#x2F;多个）</li></ul><h4 id="支持链式调用，解决回调地狱问题"><a href="#支持链式调用，解决回调地狱问题" class="headerlink" title="支持链式调用，解决回调地狱问题"></a>支持链式调用，解决回调地狱问题</h4><ul><li><p>回调地狱：回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件</p></li><li><p>缺点：不便于阅读，不便于异常处理</p></li><li><p>解决方案：使用promise链式调用</p><p>原因：Promise 的链式调用（chaining）通过 <code>.then()</code> 和 <code>.catch()</code> 方法允许我们将异步操作连接在一起，每个 <code>.then()</code> 或 <code>.catch()</code> 方法都会返回一个新的 Promise，这样我们可以继续链式调用下去，而不是嵌套回调。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getData</span>(<span class="keyword">function</span>(<span class="params">err, data1</span>) &#123;  </span><br><span class="line">  <span class="keyword">if</span> (err) &#123;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);  </span><br><span class="line">    <span class="keyword">return</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="title function_">anotherData</span>(data1, <span class="keyword">function</span>(<span class="params">err, data2</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (err) &#123;  </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(err);  </span><br><span class="line">      <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="title function_">yetAnotherData</span>(data2, <span class="keyword">function</span>(<span class="params">err, data3</span>) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (err) &#123;  </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(err);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">      &#125;  </span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 最终处理结果  </span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data3);  </span><br><span class="line">    &#125;);  </span><br><span class="line">  &#125;);  </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//传统的回调地狱，很难阅读以及维护</span></span><br><span class="line"><span class="title function_">getData</span>()  </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data1</span> =&gt;</span> &#123;  </span><br><span class="line">    <span class="comment">// 处理 data1  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">anotherData</span>(data1); <span class="comment">// 注意这里返回了一个新的 Promise  </span></span><br><span class="line">  &#125;)  </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data2</span> =&gt;</span> &#123;  </span><br><span class="line">    <span class="comment">// 处理 data2  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">yetAnotherData</span>(data2); <span class="comment">// 同样返回一个新的 Promise  </span></span><br><span class="line">  &#125;)  </span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data3</span> =&gt;</span> &#123;  </span><br><span class="line">    <span class="comment">// 处理最终结果 data3  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data3);  </span><br><span class="line">  &#125;)  </span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;  </span><br><span class="line">    <span class="comment">// 在任何步骤发生错误时，都会跳到这里  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);  </span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">//更加清晰易管理</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring基础学习</title>
      <link href="/2024/05/10/spring%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/05/10/spring%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringFrameWork"><a href="#SpringFrameWork" class="headerlink" title="SpringFrameWork"></a>SpringFrameWork</h2><p>控制反转（IOC）和面向切面编程（AOP）是SpringFrameWork中最重要的两个概念</p><h3 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>IOC将对象的创建，组装和管理的控制权从应用程序代码中反转到spring的IOC容器中，由IOC容器的ApplicationContext，</p><p>实现对象的自动装配和依赖注入。</p><ul><li>控制反转（IOC,Inversion of Control）控制指的是控制对象的创建过程，反转是反转创建对象的主体由程序员转化为容器， 在spring中容器是一个单例工厂，里面的每一个对象称之为bean，我们只需要在外部创建一个bean的构建过程，真正的创建由容器负责，在启动时期bean便完成了实例化</li></ul><h4 id="Bean的装配流程"><a href="#Bean的装配流程" class="headerlink" title="Bean的装配流程"></a>Bean的装配流程</h4><p><img src="https://image.itbaima.cn/markdown/2022/12/17/Un6qjPci2uvkL5X.png"></p><p><strong>对bean的管理都是依靠BeanFactory进行，可以通过BeanFactory对Bean进行生产和管理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();  <span class="comment">//这是BeanFactory的一个默认实现类</span></span><br><span class="line">     <span class="type">BeanDefinition</span> <span class="variable">definition</span> <span class="operator">=</span> BeanDefinitionBuilder   <span class="comment">//使用BeanDefinitionBuilder快速创建Bean定义</span></span><br><span class="line">            .rootBeanDefinition(Student.class)   <span class="comment">//Bean的类型</span></span><br><span class="line">            .setScope(<span class="string">&quot;prototype&quot;</span>)    <span class="comment">//设置作用域为原型模式</span></span><br><span class="line">            .getBeanDefinition();     <span class="comment">//生成此Bean定义</span></span><br><span class="line">    <span class="comment">//相当于实在xml文件中去注册bean</span></span><br><span class="line">    factory.registerBeanDefinition(<span class="string">&quot;hello&quot;</span>, definition);   <span class="comment">//向工厂注册Bean此定义，并设定Bean的名称</span></span><br><span class="line">    System.out.println(<span class="string">&quot;获取Bean对象：&quot;</span>+factory.getBean(<span class="string">&quot;hello&quot;</span>));  <span class="comment">//我们可以直接找工厂获取Bean对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BeanDefinition</strong>是Spring框架中的一个核心概念，它描述了Bean实例的属性和行为，并提供了创建和管理Bean实例的基础信息。BeanDefinition接口定义了一个Bean的元数据，包含了用于创建Bean对象实例的所有必要信息，如Bean的类名、作用域（如singleton或prototype等）、初始化方法、销毁方法、依赖项、属性值等。</p><h5 id="BeanDefinition有多种配置方式"><a href="#BeanDefinition有多种配置方式" class="headerlink" title="BeanDefinition有多种配置方式"></a>BeanDefinition有多种配置方式</h5><ul><li>配置文件配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.bean.Student&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注解配置</li></ul><p>使用注解则更为方便，通过@Service,@Controller等便可声明为bean对象，在配置类中加入@componentScan就可以将其加入到IOC容器中进行管理，配置类中@Bean注解的方法是用来实例化并注册Bean到Spring应用上下文中的，Bean的本质还是@Service等注解的这些类。</p><h5 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;test.xml&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) context.getBean(<span class="string">&quot;student&quot;</span>);   <span class="comment">//使用getBean方法来获取对应的对象（Bean）</span></span><br><span class="line">    student.hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationContext时IOC容器中的核心接口，是BeanFactory的子接口，相较于BeanFactory有更丰富的功能和更好的性能，负责实例化，配置和管理Bean对象，以及建立这些对象间的依赖关系，当启动Spring项目时，他会创建一个ApplicationContext的实例，然后由他负责初始化和配置应用中的所有对象</p><p>现在，我们就已经知道，Bean实际上是一开始通过BeanDefinitionReader进行扫描，然后将所有Bean以BeanDefinition对象的形式注册到对应的BeanFactory中进行集中管理，而我们使用的ApplicationContext实际上内部就有一个BeanFactory在进行Bean管理，这样容器才拥有了最基本的Bean管理功能。</p><h4 id="使用IOC容器管理的好处"><a href="#使用IOC容器管理的好处" class="headerlink" title="使用IOC容器管理的好处"></a>使用IOC容器管理的好处</h4><ul><li><p>降低代码耦合度</p><p>如果不使用IOC容器管理，则两个相互依赖的类则需要手动创建出实例，如果其中一个类需要改变，则需要改变的大量代码，使用IOC容器后，则不再创建实例，而是声明需要的依赖，由容器负责在运行时注入正确的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 耦合度低的UserService示例（使用接口）  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 声明依赖，但不创建实例  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 通过构造函数注入依赖  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserRepository userRepository)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ... 其他业务方法  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// UserRepository接口  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> &#123;  </span><br><span class="line">    <span class="comment">// ... 定义方法  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// UserRepository的具体实现  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseUserRepository</span> <span class="keyword">implements</span> <span class="title class_">UserRepository</span> &#123;  </span><br><span class="line">    <span class="comment">// ... 实现方法  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 另一个UserRepository的实现（比如API调用）  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiUserRepository</span> <span class="keyword">implements</span> <span class="title class_">UserRepository</span> &#123;  </span><br><span class="line">    <span class="comment">// ... 实现方法  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p> 在这个例子中，<code>UserService</code>只依赖于<code>UserRepository</code>接口，而不是具体的实现类。这意味着我们可以轻松地替换<code>UserRepository</code>的实现，而无需修改<code>UserService</code>的代码。只需在配置文件中修改相关的代码</p><ul><li><p>安全性</p><p>在高并发情况下，如果每一步都需要new一个对象，则会增大对内存的压力，而IOC容器为单例模式，每次只需从缓存中获取，这样内存抖动不会太严重，保证程序的可靠性稳定性。</p></li></ul><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，旨在通过预编译方式和运行期间间动态代理实现程序功能的统一维护的一种技术。AOP 是对 OOP（Object-Oriented Programming，面向对象编程）的补充，用于处理系统中分布于各个模块的横切关注点（cross-cutting concerns），如日志、事务管理、安全等。这些横切关注点通常与业务逻辑无关，但会散落到各个模块中，导致代码难以维护。</p><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ol><li><strong>切面（Aspect）</strong>：切面是一个横切关注点的模块化，这个关注点可能会横切多个对象。切面用来封装横切关注点（cross-cutting concern）的代码，该代码直接影响了业务类代码的执行。</li><li><strong>连接点（Joinpoint）</strong>：是程序执行过程中某个特定的位置，例如方法执行前，方法执行后等，可以理解为终须中可能插入前面的地方</li><li><strong>通知（Advice）</strong>：在特定的连接点，AOP框架执行的动作。例如，一个方法调用前打印日志，就是一个通知。</li><li><strong>切点（Pointcut）</strong>：切点用于定义哪些连接点应该被拦截。</li></ol><p>通过切入点来匹配程序中的特定连接点，在这些连接点上执行通知，这种通知是在连接点前后执行，也可以将连接点包围起来。</p><p><strong>连接点和切点的差异</strong>：</p><ol><li><strong>定义范围</strong>：连接点是程序执行过程中的一个特定位置，是一个具体的点；而切点是一组连接点的集合，是一个更广泛的概念。</li><li><strong>作用对象</strong>：连接点是AOP可以插入额外代码或逻辑的地方，是AOP框架操作的对象；而切点则是用于指定哪些连接点需要被拦截并应用通知，是定义AOP操作范围的工具。</li><li><strong>使用方式</strong>：在AOP中，连接点通常不需要显式定义，而是由AOP框架在运行时自动识别和定位；而切点则需要显式定义，通过规则或表达式来指定需要拦截的连接点。</li></ol><p>总结来说，连接点和切点在AOP中各自扮演着不同的角色。连接点是AOP框架操作的具体位置，而切点则是用于定义AOP操作范围的工具，通过指定需要拦截的连接点来实现对程序的增强或修改。</p><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>在原始的springFramWork中，建立一个项目需要经过繁杂的依赖导入以及配置，依赖导入还经常会出现版本不匹配的问题，而SpringBoot通过其起步依赖和自动配置的特性就完美的解决了这两个问题，降低了学习成本，实现了开箱即用。</p><h3 id="启动流程（简化版）"><a href="#启动流程（简化版）" class="headerlink" title="启动流程（简化版）"></a>启动流程（简化版）</h3><ul><li>创建IOC容器  createApplicationContext(..)</li><li>加载源配置类  loadSourceClass(..)  源配置类通常是main方法所在的类，而且会被注解@SpringBootApplication所修饰，我们又称为主类。</li><li>加载并处理所有的配置类  processConfigurationClasses(..)   SpringBoot会自动找到所有配置类，然后加载处理他们。“自动配置”就属于其中的一环。</li><li>实例化所有的单例bean  instantiateSingletonBeans(..)   实例化所有的单例Bean。“依赖注入”和“自动装配”就属于其中的环节</li><li>启动web服务器</li></ul><h3 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h3><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ol><li><strong>简化配置</strong>：Spring Boot的起步依赖通过预定义和整合了常用的依赖项，极大地简化了项目的配置工作。例如，当你添加了<code>spring-boot-starter-web</code>依赖后，Spring Boot会自动配置内嵌的Web服务器、Spring MVC和其他相关组件，而无需你手动配置这些组件。</li><li><strong>快速启动</strong>：由于减少了手动配置的需要，开发者可以更快地启动和交付高质量的应用。你只需选择适合项目需求的起步依赖，Spring Boot就会自动为你处理底层的配置和依赖管理。</li><li><strong>一致性和可维护性</strong>：通过使用预定义的起步依赖，可以确保项目在不同环境和开发者之间具有一致性和可维护性。这些起步依赖都经过Spring Boot团队的精心选择和测试，以确保它们之间的兼容性和稳定性。</li><li><strong>减少错误</strong>：由于起步依赖已经处理了底层框架和库的配置和管理，因此可以减少因手动配置错误而导致的运行时问题。这有助于降低项目的风险和成本。</li><li><strong>易于扩展</strong>：虽然起步依赖为开发者提供了很多便利，但它们仍然是可扩展的。如果你需要添加或修改某个特定的依赖项，你可以很容易地在项目中添加或排除它。</li></ol><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>SpringBoot自动配置就是Spring容器启动后，一些配置类，bean对象就自动存入了IOC容器中，不需要我们手动去声明， 从而简化了开发，省去了繁杂的配置操作。</p><h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><ul><li>广义的配置类：被注解@Component直接或间接修饰的某个类，即我们常说的Spring组件，其中包括了@Configuration类</li><li>狭义的配置类：特指被注解@Configuration所修饰的某个类，又称@configuration类。</li></ul><p>如果没有特殊说明，我们说的配置类一般指广义的配置类，狭义的配置类我们一般称@Configuration类。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>从源配置类开始通过注解@ComponentScan和注解@Implort不断地递归遍历新的配置类，直到没有新的配置类被发现位置，得到的一个配置类集合，将配置类本身注册到IOC容器中，处理配置类中的@Bean方法，将其返回类型注册到IOC容器中，处理通过@Import导入的ImportBeanDefinitionRegistrar</p><p>我们的启动类上有<code>@SpringBootApplication</code>，<code>@SpringBootApplication</code>是<code>@SpringBootConfiguration</code>，<code>@ComponentScan</code>，<code>@EnableAutoConfiguration</code>这三个注解组合而成</p><ul><li><p><code>@SpringBootConfiguration</code> 注解表明启动类是一个特殊的配置类，它间接地由 <code>@Configuration</code> 注解修饰，表示该类是一个Spring配置类，可以定义Bean。</p></li><li><p><code>@ComponentScan</code> 注解用于告诉Spring Boot在哪些包中查找Spring组件、配置和服务。默认情况下，它会扫描启动类所在的包及其子包。</p></li><li><p><code>@EnableAutoConfiguration</code> 注解是Spring Boot的核心特性之一，它告诉Spring Boot根据添加的jar依赖项、类路径中的其他项以及各种属性设置来自动配置Spring应用。这个注解通过<code>@Import</code>注解引入了<code>AutoConfigurationImportSelector</code>，它实现了<code>ImportSelector</code>接口，从而可以决定在运行时哪些自动配置类应当被添加到应用中。</p></li><li><p><code>AutoConfigurationImportSelector</code> 在其<code>selectImports</code>方法中，通过加载<code>META-INF/spring.factories</code>文件（在Spring Boot 2.7及之前版本，如今读取的是<code>META-INF</code>目录下的<code>.imports</code>文件）来确定哪些自动配置类需要被加载。这个文件包含了多个自动配置类的全类名列表，这些类包含了各种Bean的定义和配置。</p></li><li><p><code>@Condition</code> 注解及其衍生注解（如<code>@ConditionalOnClass</code>、<code>@ConditionalOnProperty</code>等）用于在自动配置过程中添加条件。如果条件满足，相关的Bean就会被加载到Spring容器中。否则，这些Bean会被忽略。</p></li><li><p>读取到的自动配置类会创建相应的<code>BeanDefinition</code>。<code>BeanDefinition</code>是Spring框架中用于描述Bean的元数据对象，包含了Bean的各种属性（如名称、作用域、初始化方法等）和配置信息。在Spring容器启动过程中，会根据这些<code>BeanDefinition</code>来创建Bean的实例。</p></li><li><p>最后，Spring容器会按照这些<code>BeanDefinition</code>的定义来实例化、配置和组装Bean，从而构建出整个应用的对象图。</p></li></ul><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><ul><li><p>@Import</p><p><code>@Import</code>注解是一个非常重要的注解，它允许你导入其他配置类、组件或配置，以便在当前的Spring上下文中使用。这个注解主要用于扩展Spring的配置和功能。</p><ul><li><p><strong>导入普通类</strong>：你可以使用@Import注解来导入一个普通类使之成为Bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(UserService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfig</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>导入配置类</strong>：你可以使用<code>@Import</code>注解来导入其他配置类，这样你就可以在一个配置类中组合多个配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@Import(AnotherConfig.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfig</span> &#123;  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>导入ImportSelector的实现</strong>：<code>ImportSelector</code>是一个接口，它允许你动态地选择并返回要导入的配置类。这对于根据条件或外部配置来加载不同的配置类特别有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfig</span> &#123;  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.example.AnotherConfig&quot;</span>&#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>导入ImportBeanDefinitionRegistrar的实现</strong>：<code>ImportBeanDefinitionRegistrar</code>接口允许你在运行时动态地注册bean定义。这给了你更多的灵活性，可以基于复杂的条件或外部输入来注册bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@Import(MyImportBeanDefinitionRegistrar.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfig</span> &#123;  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;  </span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">rootBeanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(AnotherBean.class);  </span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;anotherBean&quot;</span>, rootBeanDefinition);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h4><h5 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h5><p>自定义mybatis的starter</p><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li><p>创建<code>dmatis-spring-boot-autoconfigure</code>模块，提供自动配置功能，并自定义配置文件</p><p><code>META-INF/spring/xxx.imports</code></p></li><li><p>创建<code>dmatis-spring-boot-starter</code>模块，在<code>stater</code>模块中引入自动配置模块</p></li></ul><h5 id="dmatis-spring-boot-autoconfigure模块"><a href="#dmatis-spring-boot-autoconfigure模块" class="headerlink" title="dmatis-spring-boot-autoconfigure模块"></a><code>dmatis-spring-boot-autoconfigure</code>模块</h5><p>在pom文件中导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration</span><span class="comment">//表示这是一个自动配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisAutoConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">(BeanFactory beanFactory)</span>&#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">mapperScannerConfigurer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        <span class="comment">//扫描的包：启动类所在的包及其子包</span></span><br><span class="line">        List&lt;String&gt; packages = AutoConfigurationPackages.get(beanFactory);</span><br><span class="line">        <span class="type">String</span> <span class="variable">p</span> <span class="operator">=</span> packages.get(<span class="number">0</span>);</span><br><span class="line">        mapperScannerConfigurer.setBasePackage(p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//扫描的注解</span></span><br><span class="line">        mapperScannerConfigurer.setAnnotationClass(Mapper.class);</span><br><span class="line">        <span class="keyword">return</span> mapperScannerConfigurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写配置文件<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.example.config.MybatisAutoConfig  #配置类的全类名</span><br></pre></td></tr></table></figure><p>至此<code>dmatis-spring-boot-autoconfigure</code>已具备自动配置的功能了</p><h5 id="dmatis-spring-boot-starter模块"><a href="#dmatis-spring-boot-starter模块" class="headerlink" title="dmatis-spring-boot-starter模块"></a><code>dmatis-spring-boot-starter</code>模块</h5><p>在pom文件中导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dmybatis-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以下的依赖建议再导一遍，以便以后需要对这些依赖进行一个排除更加方便，这也是官方推荐的做法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>至此<code>dmatis-spring-boot-starter</code>已具备依赖管理的功能了，在项目中只需要引入该<code>starter</code>这个工程就可以直接整合mybatis了</p><h2 id="SSM框架（Spring-Spring-MVC-Mybatis）"><a href="#SSM框架（Spring-Spring-MVC-Mybatis）" class="headerlink" title="SSM框架（Spring+Spring MVC+Mybatis）"></a>SSM框架（Spring+Spring MVC+Mybatis）</h2><h3 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h3><ol><li><strong>轻量级与高效性</strong>：SSM框架是一种轻量级的开发框架，它部署简单、启动速度快，并且具有高效的性能表现，能够快速响应用户请求。这种轻量级和高效性的特点使得SSM框架成为开发企业级Java Web应用程序的理想选择。</li><li><strong>模块化设计</strong>：SSM框架采用了模块化的设计，将业务逻辑分成多个模块。这种设计使得开发人员可以更加专注于单个模块的开发和维护，提高了开发效率。同时，模块之间的松耦合也使得整个应用程序更加易于扩展和维护。</li><li><strong>灵活性</strong>：SSM框架采用了依赖注入（DI）和面向切面编程（AOP）的思想，这使得开发人员可以更加灵活地组织和管理代码。依赖注入可以帮助开发人员实现代码之间的解耦，而AOP则允许开发人员在不修改业务代码的情况下，为整个应用程序添加或修改横切关注点。</li><li><strong>可扩展性</strong>：SSM框架具有出色的可扩展性。Spring框架提供了丰富的扩展点和插件机制，可以方便地扩展和定制框架的功能。这使得开发人员可以根据具体的业务需求，灵活地添加或修改框架的功能，以满足不同的需求。</li><li><strong>易于集成</strong>：SSM框架与其他第三方库和工具的集成比较容易。例如，它可以轻松地与数据库、缓存、消息队列等进行集成，从而提高了整个应用程序的可用性和可维护性。</li><li><strong>清晰的分层结构</strong>：SSM框架的分层结构非常清晰，包括表示层（由Spring MVC负责）、业务逻辑层（由Spring负责）和数据访问层（由MyBatis负责）。这种清晰的分层结构使得开发人员能够快速地定位和解决问题，提高了开发效率和维护性。</li><li><strong>易于维护</strong>：由于SSM框架的模块化设计和清晰的分层结构，使得代码结构清晰、易于维护。当某个模块出现问题时，开发人员可以快速地定位并修复问题，而不需要对整个应用程序进行大规模的修改。</li></ol><p>SSM框架在Java Web应用程序开发中具有许多显著的优点，这些优点使得它成为开发企业级Java Web应用程序的首选框架之一。</p><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>在SSM框架中，Spring框架作为基础框架，为整个应用程序提供了强大的支持和保障。它使得开发者可以更加专注于业务逻辑的实现，而无需关心底层框架的细节和复杂性。</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ol><li><strong>轻量级开源框架</strong>：Spring是一个轻量级的Java EE框架，它使得企业级应用程序的开发变得更为简单和高效。</li><li><strong>分层结构</strong>：Spring为不同的层都提供了企业级解决方案，包括web层（通过Spring MVC）、service层（通过Spring的各种服务组件）和dao层（通过JDBCTemplate等）。</li><li><strong>核心思想</strong>：Spring的核心思想是IOC（控制反转）和AOP（面向切面编程）。通过IOC，Spring可以自动管理对象的生命周期和依赖关系，从而降低代码之间的耦合度。而AOP则允许开发者在不修改已有代码的情况下，增加新的功能，如日志、事务管理等。</li><li><strong>容器功能</strong>：Spring是一个对象容器框架，它负责创建和管理应用程序中的对象。开发者只需要定义好对象的配置信息（如依赖关系、生命周期等），然后Spring就会在运行时自动创建和管理这些对象。</li><li><strong>事务管理</strong>：Spring提供了强大的事务管理功能，可以支持声明式事务和编程式事务。这使得开发者可以更容易地实现复杂的事务逻辑，并保证数据的完整性和一致性。</li><li><strong>集成性</strong>：Spring可以很容易地与其他框架和库进行集成，如Hibernate、MyBatis等。这使得开发者可以根据项目的需求选择合适的技术栈，并快速地构建出高效的应用程序。</li></ol><h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>Spring MVC 是一个基于 Java 的实现了 Web MVC 设计模式的请求驱动类型的轻量级 Web 框架，它可以帮助开发者简化 Web 应用程序的开发。</p><h4 id="MVC（Model-View-Controller）"><a href="#MVC（Model-View-Controller）" class="headerlink" title="MVC（Model View Controller）"></a>MVC（Model View Controller）</h4><ul><li><p>Model(模型层)</p><p>在项目中，模型层通常指的是业务逻辑和数据处理的部分。它包含了与数据交互的业务对象（Service）和数据访问对象（DAO），以及用于传输数据的 JavaBean（DTO）或实体类（Entity）。</p><p>例如，在一个电商项目中，模型层可能包含：</p><ol><li><strong>UserService</strong>：负责处理与用户相关的业务逻辑，如用户注册、登录、查询等。</li><li><strong>ProductDAO</strong>：负责与数据库交互，执行产品数据的增删改查操作。</li><li><strong>UserDTO</strong>：用于在前后端之间传输用户数据的简单 JavaBean，包含用户的ID、用户名、密码等信息。</li></ol></li><li><p>View（视图层）</p><p>在前后端分离的模式下，视图层主要由前端应用负责实现，如 Web 页面、移动应用界面等。后端通过 API 接口向前端提供数据，前端则负责展示这些数据并与用户进行交互。</p></li><li><p>Controller（控制层）</p><p>在 Spring MVC 中，控制层负责接收前端发送的请求，调用模型层处理业务逻辑和数据，然后将处理结果返回给前端。在前后端分离的项目中，控制层通常负责处理 HTTP 请求，并将数据以 JSON、XML 等格式返回给前端。</p><p>例如，在电商项目中，控制层可能包含：</p><ol><li><strong>UserController</strong>：负责处理与用户相关的 HTTP 请求，如用户注册、登录等。它会调用 UserService 来处理业务逻辑，并将处理结果转换为 JSON 格式返回给前端。</li><li><strong>ProductController</strong>：负责处理与产品相关的 HTTP 请求，如查询产品列表、获取产品详情等。它会调用 ProductDAO 来从数据库中获取产品数据，并将数据转换为 JSON 格式返回给前端。</li></ol></li></ul><h4 id="DispatcherServlet（前端控制器）"><a href="#DispatcherServlet（前端控制器）" class="headerlink" title="DispatcherServlet（前端控制器）"></a>DispatcherServlet（前端控制器）</h4><p>核心工作是请求的分发和响应结果的处理</p><ol><li><strong>接收请求</strong>：<code>DispatcherServlet</code>接收所有来自Web客户端（如浏览器）的HTTP请求。</li><li><strong>解析请求</strong>：解析请求中的信息，包括请求参数、HTTP方法（GET、POST等）、请求的URI等。</li><li><strong>确定处理程序</strong>：根据请求的URI和其他相关信息，通过HandlerMapping（处理器映射）确定要处理这个请求的处理器（通常是Controller中的一个方法）。</li><li><strong>调用处理程序</strong>：调用确定的处理器来处理请求。这通常涉及调用一个或多个服务层组件来处理业务逻辑。</li><li><strong>解析并渲染视图</strong>：处理器返回一个ModelAndView对象，其中包含要渲染的视图名称和模型数据。<code>DispatcherServlet</code>使用ViewResolver（视图解析器）来确定要渲染的视图类型（如JSP、Thymeleaf等），并将模型数据传递给视图进行渲染。</li><li><strong>返回响应</strong>：渲染后的视图作为HTTP响应返回给Web客户端。</li></ol><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>MyBatis是一个优秀的持久层框架，它支持自定义SQL、存储过程以及高级映射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的XML或注解来配置和映射原始类型、接口和Java POJO（Plain Old Java Objects，普通的Java对象）为数据库中的记录。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>在SSM框架中，MyBatis的主要职责是与数据库进行交互，完成数据的增删改查操作。它封装了底层的JDBC API，使得开发者可以更加专注于SQL语句的编写和数据库操作，而无需关心JDBC连接、语句创建、参数设置和结果集处理等繁琐的细节。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>苍穹外卖总结</title>
      <link href="/2024/05/04/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E6%80%BB%E7%BB%93/"/>
      <url>/2024/05/04/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Nginx是一个高性能的HTTP和反向代理服务器，它以其高并发处理能力和低内存占用而著称，在静态内容处理方面占有优势，因此实际生产中，经常与tomcat结合使用（tomcat为重量型服务器，处理高并发能力较弱），Nginx可以作为Tomcat的前端服务器，提供静态文件服务（如HTML、CSS、JavaScript等），并作为反向代理服务器将请求转发给Tomcat。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><p>提高访问速度</p><p>在单次请求和高并发请求环境下，Nginx都会比其他web服务器相应的更快，Nginx之所以有这么大的高并发处理能力，在于其采用了多进程和I&#x2F;O多路复用的底层实现</p></li><li><p>进行负载平衡</p><p>所谓负载平衡额就是把大量请求按照我们所指定的方式均衡的分配给集群中的每台服务器</p></li><li><p>保证后端服务安全</p><p>通过反向代理，隐藏真实的服务器IP地址</p></li><li><p>热部署</p><p>互联网项目要求7*24小时的进行提供服务，针对这一要求，Nginx提供了热部署功能，即可以在Nginx不停止的情况下，对Nginx进行文件升级，更新配置和更换日志文件。</p></li></ul><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><ol><li><strong>定义与原理</strong>：反向代理是以代理服务器来接受互联网上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给互联网上请求连接的客户端。此时，代理服务器对外就表现为一个服务器。</li><li><strong>主要功能</strong>：反向代理的主要功能包括负载均衡（分发流量到多台服务器上，保证服务的可用性和稳定性）、缓存（缓存动态或静态内容，减轻后端服务器的压力，提高页面访问速度）、安全性（隐藏真实的服务器IP地址，提高系统的安全性和隐私性）以及压缩（对页面进行压缩，减少页面的大小，提高页面的加载速度）。</li></ol><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal:"></a>ThreadLocal:</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>ThreadLocal并不是一个Thread(线程),而是Thread的一个局部变量</p><p>ThreadLocal为每一个线程提供单独一份的存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。换句话说，<code>ThreadLocal</code> 为每个线程提供了其自己的变量副本，因此每个线程都可以独立地改变自己的副本，而不会影响其他线程的副本。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li><p><strong>创建 ThreadLocal 实例</strong>：</p><p>使用 <code>ThreadLocal</code> 类，我们首先需要创建一个 <code>ThreadLocal</code> 实例，然后可以通过这个实例来访问线程局部变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></li><li><p><strong>设置和获取值</strong>：</p><ul><li><code>set(T value)</code>: 用于在当前线程中设置线程局部变量的值。</li><li><code>get()</code>: 用于获取当前线程中线程局部变量的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.set(<span class="string">&quot;Thread-A Value&quot;</span>);  </span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get(); <span class="comment">// 在当前线程中，这将返回 &quot;Thread-A Value&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>初始值</strong></p><p>默认情况下，如果没有为 <code>ThreadLocal</code> 设置值，那么调用 <code>get()</code> 方法将返回 <code>null</code>。但我们可以提供一个初始值，通过覆盖 <code>ThreadLocal</code> 的 <code>initialValue()</code> 方法来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">initialValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Initial Value&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>ThreadLocal</code> 可能会导致内存泄漏，因为它会在线程的生命周期内保持其值。如果线程长时间运行，并且 <code>ThreadLocal</code> 变量不再需要，但线程没有结束，那么这些变量占用的内存就无法被垃圾回收器回收。因此，在使用完 <code>ThreadLocal</code> 后，最好手动调用 <code>remove()</code> 方法来清除线程局部变量。</li><li><code>ThreadLocal</code> 不是解决并发问题的银弹。在大多数情况下，应该优先考虑使用同步机制（如 <code>synchronized</code> 或 <code>Lock</code>）来确保线程安全。<code>ThreadLocal</code> 只是在某些特定场景下提供了一种更优雅的解决方案。</li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis是一个基于内存的key-value结构数据库,与之对应的mysql是基于磁盘的数据库</p><p>由于基于内存存储，所以他的读写性能高，适用于储存热点数据（短时间大量访问数据）如热点商品，资讯，新闻</p><p>而mysql这种传统的数据库是基于磁盘IO进行数据读取，随着访问量的增大，这种读取方式劣势明显，于是redis应运而生</p><h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><ul><li>性能极高</li><li>数据类型丰富，单键值对最大支持512M大小的数据</li><li>简单易用，支持所有主流编程语言</li><li>支持数据持久化，主从复制，哨兵模式等高可用特性</li></ul><h3 id="springBoot整合redis"><a href="#springBoot整合redis" class="headerlink" title="springBoot整合redis"></a>springBoot整合redis</h3><h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">  <span class="comment">#Redis服务器地址</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.3</span></span><br><span class="line">    <span class="comment">#端口</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment">#使用几号数据库</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>starter已经给我们提供了两个默认的模板类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;RedisOperations.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisAutoConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">        name = &#123;&quot;redisTemplate&quot;&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">    <span class="keyword">public</span> StringRedisTemplate <span class="title function_">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>(redisConnectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需注入StringRedisTemplate来使用模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringBootTestApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; operations = template.opsForValue();</span><br><span class="line">        operations.set(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;xxxxx&quot;</span>);   <span class="comment">//设置值</span></span><br><span class="line">        System.out.println(operations.get(<span class="string">&quot;c&quot;</span>));   <span class="comment">//获取值</span></span><br><span class="line">      </span><br><span class="line">        template.delete(<span class="string">&quot;c&quot;</span>);    <span class="comment">//删除键</span></span><br><span class="line">        System.out.println(template.hasKey(<span class="string">&quot;c&quot;</span>));   <span class="comment">//判断是否包含键</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>WebSocket是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工通信——浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。</p><p>过程：客户端向服务端发送一个请求（HandShake）握手，服务端对客户端进行应答（Acknowledgement）,这样，客户端与服务端便建立好链接，双方可以进行双向通信。 </p><h3 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h3><ul><li><p>双向实时通信</p><p>允许在单个，长时间的链接上进行双向实时通信。在需要快速实时更新的应用程序里，比Http更加高效。</p></li><li><p>降低延迟</p><p>连接一旦建立便会保持开放，数据可以在客户端和服务器之间以比HTTP更低的延迟进行传输</p></li><li><p>更高效的资源利用</p><p>可以减少重复的请求和响应的开销，因为它的链接只需建立一次。</p><p>​</p></li></ul><p></p><h3 id="建立webSocket链接"><a href="#建立webSocket链接" class="headerlink" title="建立webSocket链接"></a>建立webSocket链接</h3><p>需要通过HTTP发送一次常规的Get请求，并在请求头中带上Upgrade，告诉服务器，要求从HTTP升级为webSocket，链接便建立成功，之后客户端和服务端就可以进行互相通信。</p><h3 id="使用代码"><a href="#使用代码" class="headerlink" title="使用代码"></a>使用代码</h3><h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServerEndpointExporter <span class="title function_">serverEndpointExporter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServerEndpointExporter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一旦ServerEndpointExporter被注册为bean，Spring就会扫描你的应用程序中的@ServerEndpoint注解，并自动配置  和注册相应的WebSocket端点。这使得你能够很容易地将WebSocket集成到Spring应用程序中。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WebSocket的服务"><a href="#WebSocket的服务" class="headerlink" title="WebSocket的服务"></a>WebSocket的服务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/ws/&#123;sid&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放会话对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Session&gt; sessionMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接建立成功调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session, <span class="meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端：&quot;</span> + sid + <span class="string">&quot;建立连接&quot;</span>);</span><br><span class="line">        sessionMap.put(sid, session);<span class="comment">//存放会话对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送过来的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, <span class="meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到来自客户端：&quot;</span> + sid + <span class="string">&quot;的信息:&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sid</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(<span class="meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接断开:&quot;</span> + sid);</span><br><span class="line">        sessionMap.remove(sid);<span class="comment">//移除该会话对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 群发</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendToAllClient</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        Collection&lt;Session&gt; sessions = sessionMap.values();<span class="comment">//获取所有客户端</span></span><br><span class="line">        <span class="keyword">for</span> (Session session : sessions) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//服务器向客户端发送消息</span></span><br><span class="line">                session.getBasicRemote().sendText(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HTTP</p><p>HTTP也是基于TCP的一种协议。请求响应模式，只有客户端向服务端发送请求，服务端才可以响应，不可颠倒，响应过后链接断开，故可称其为短链接</p><h2 id="JWT相关总结"><a href="#JWT相关总结" class="headerlink" title="JWT相关总结"></a>JWT相关总结</h2><p>（1）令牌的生成：由三部分组成，需要设置令牌的签名算法和签名密钥（保密，只能自己拥有，可随意设置）,过期时间，和主题数据（一般为用户id）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String secretKey, <span class="type">long</span> ttlMillis, Map&lt;String, Object&gt; claims)</span> &#123;</span><br><span class="line">    <span class="comment">// 指定签名的时候使用的签名算法，也就是header那部分</span></span><br><span class="line">    <span class="type">SignatureAlgorithm</span> <span class="variable">signatureAlgorithm</span> <span class="operator">=</span> SignatureAlgorithm.HS256;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成JWT的时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">expMillis</span> <span class="operator">=</span> System.currentTimeMillis() + ttlMillis;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(expMillis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置jwt的body</span></span><br><span class="line">    <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">            <span class="comment">// 如果有私有声明，一定要先设置这个自己创建的私有的声明，这个是给builder的claim赋值，一旦写在标准的声明赋值之后，就是覆盖了那些标准的声明的</span></span><br><span class="line">            .setClaims(claims)</span><br><span class="line">            <span class="comment">// 设置签名使用的签名算法和签名使用的秘钥</span></span><br><span class="line">            .signWith(signatureAlgorithm, secretKey.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">            <span class="comment">// 设置过期时间</span></span><br><span class="line">            .setExpiration(exp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> builder.compact();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 令牌的校验：即token的解密，通过JWTs的parser方法，设置密钥，以及需要解析的token，如果该过程为出异常，及说明令牌的校验成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWT</span><span class="params">(String secretKey, String token)</span> &#123;</span><br><span class="line">    <span class="comment">// 得到DefaultJwtParser</span></span><br><span class="line">    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">            <span class="comment">// 设置签名的秘钥</span></span><br><span class="line">            .setSigningKey(secretKey.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">            <span class="comment">// 设置需要解析的jwt</span></span><br><span class="line">            .parseClaimsJws(token).getBody();</span><br><span class="line">    <span class="keyword">return</span> claims;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两点通常封装在一个util类中，以便登陆时进行校验</p><p>(3)登录时所需要的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/employee&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeService employeeService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtProperties jwtProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> employeeLoginDTO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;EmployeeLoginVO&gt; <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> EmployeeLoginDTO employeeLoginDTO)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;员工登录：&#123;&#125;&quot;</span>, employeeLoginDTO);</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeService.login(employeeLoginDTO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//登录成功后，生成jwt令牌</span></span><br><span class="line">        Map&lt;String, Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        claims.put(JwtClaimsConstant.EMP_ID, employee.getId());</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtil.createJWT(</span><br><span class="line">                jwtProperties.getAdminSecretKey(),</span><br><span class="line">                jwtProperties.getAdminTtl(),</span><br><span class="line">                claims);</span><br><span class="line"></span><br><span class="line">        <span class="type">EmployeeLoginVO</span> <span class="variable">employeeLoginVO</span> <span class="operator">=</span> EmployeeLoginVO.builder()</span><br><span class="line">                .id(employee.getId())</span><br><span class="line">                .userName(employee.getUsername())</span><br><span class="line">                .name(employee.getName())</span><br><span class="line">                .token(token)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(employeeLoginVO);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>(4)拦截器的设置（interceptor）根据验证jwt来判断是否登录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtTokenAdminInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtProperties jwtProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验jwt</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//判断当前拦截到的是Controller的方法还是其他资源</span></span><br><span class="line">        <span class="keyword">if</span> (!(handler <span class="keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="comment">//当前拦截到的不是动态方法，直接放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、从请求头中获取令牌</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(jwtProperties.getAdminTokenName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、校验令牌</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;jwt校验:&#123;&#125;&quot;</span>, token);</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);</span><br><span class="line">            <span class="type">Long</span> <span class="variable">empId</span> <span class="operator">=</span> Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());</span><br><span class="line">            log.info(<span class="string">&quot;当前员工id：&quot;</span>, empId);</span><br><span class="line">            BaseContext.setCurrentId(empId);</span><br><span class="line">            <span class="comment">//3、通过，放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">//4、不通过，响应401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="消息推送的常见方式"><a href="#消息推送的常见方式" class="headerlink" title="消息推送的常见方式"></a>消息推送的常见方式</h2><p>（1）轮询：浏览器以指定的时间间隔向服务器发送HTTP请求，服务器实时返回数据给浏览器</p><p>   缺点：1-由于定时发送请求，可能会导致服务器数据更新，此时浏览器未发送请求，则会造成延迟</p><p>​               2-由于定时要向服务器发送请求，会造成服务器压力过大</p><p>（2）长轮询：浏览器发出ajax请求，服务器端收到请求后，会阻塞请求直到有数据或请求超时才返回</p><p>对比：由于有等待的过程，所以间隔时间可以长一些，相对于轮询对服务端造成的压力小。</p><p>并且由于必须收到数据才可返回，相对于轮询的延迟也会小。</p><p>（3）SSE 服务器发送事件</p><p>是服务端打开的和客户端之间的一个单向通道。  服务端相应的不再是一次性的数据包，而是text&#x2F;event-stream类型的数据流信息。  服务器有数据变更时将数据流式传输到客户端。</p><p>（4）WebSocket：如上。</p><p>补充：全双工：允许数据在两个方向上同时传输。</p><p>​           半双工：允许数据在两个方向上传输，但是同一个时间段内只允许一个方向上传输。</p><p>JAVA WebSocket应用由一系列的EndPoint组成。EndPoint是一个java对象，代表WebSocket链接的一端</p><p>每一个客户端，服务端都会创建一个EndPoint与之一对一对应，对于服务端，我们可以视为处理具体WebSocket消息的接口</p><p>EndPoint实例在WebSocket握手时创建，并在客户端与服务端连接过程中有效，最后在连接关闭时结束</p><p>服务端API</p><p>发送消息：1-服务端接受客户端发送的数据 常用：注解式@OnMessage</p><p>​         2-服务端推送数据给客户端：由RemoteEndpoint完成，实例由Session维护</p><p>​         通过session.getBasicRemote获取同步消息发送的实例，调用sendXXX()发送消息</p><p>​         通过session.getAsyncRemote获取异步消息发送的实例，调用sendXXX()发送消息</p><h2 id="AOP-面向切面"><a href="#AOP-面向切面" class="headerlink" title="AOP:面向切面"></a>AOP:面向切面</h2><p>动态代理是面向切面编程最主流的实现。而springAOP是spring框架的高级技术，旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程。对特定的方法功能进行加强或改变其功能。</p><p>好处：代码无侵入，减少重复代码，提高开发效率，维护方便</p><p>核心概念</p><p>（1）连接点：joinPoint，可以被AOP控制的方法（暗含方法执行时的相关信息）</p><p>通过joinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名，方法名，方法参数。 </p><p>joinPoint可获得方法的签名，而方法签名包含了方法的名称，返回类型及参数列表</p><p>（2）通知：Advice，指那些重复的逻辑，也就是共性功能（最终体现为一个方法）</p><p>（3）切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法被执行时被应用，通常通过切点表达式实现其功能。</p><p>区别：连接点时程序中所有潜在的可插入通知的位置，切入点则是从这些连接点筛选出来的，实际要附加通知的具体位置</p><p>（4）切面：Aspect，描述通知与切入点的对应关系（通知加切入点）</p><p>（5）目标对象：Target,通知所应用的对象</p><p>切点表达式（带？可省略）execution(访问修饰符？返回值 包名.类名.?方法名（方法参数）throws 异常？)</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理是在运行时动态的为对象创建代理的技术</p><table><thead><tr><th align="center"></th><th align="center">必须实现接口</th><th align="center">支持拦截public方法</th><th align="center">支持拦截protected方法</th><th align="center">拦截默认作用域方法</th></tr></thead><tbody><tr><td align="center">JDK动态代理</td><td align="center">是</td><td align="center">是</td><td align="center">否</td><td align="center">否</td></tr><tr><td align="center">CGLIB代理</td><td align="center">否</td><td align="center">是</td><td align="center">是</td><td align="center">是</td></tr></tbody></table><p>虽然CGLIB代理支持拦截非public作用域方法调用，但不同对象交互是，建议还是以public方法调用为主</p><h2 id="文件上传（阿里云OSS）"><a href="#文件上传（阿里云OSS）" class="headerlink" title="文件上传（阿里云OSS）"></a>文件上传（阿里云OSS）</h2><h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><p>前往阿里云官方完成注册等流程，新建一个bucket，获取到如下四个数据 access-key-id  access-key-secret  endpoint  bucket-name</p><p>写在配置文件中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">alioss:</span></span><br><span class="line">  <span class="attr">access-key-id:</span> </span><br><span class="line">  <span class="attr">access-key-secret:</span> </span><br><span class="line">  <span class="attr">endpoint:</span> </span><br><span class="line">  <span class="attr">bucket-name:</span> </span><br></pre></td></tr></table></figure><p>后端相应的接口</p><ul><li>接受上传来的文件</li><li>将文件存储起来（OSS）</li><li>返回文件的url</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/common&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AliOssUtil aliOssUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt;upload(MultipartFile file)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">            <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">ObjectName</span> <span class="operator">=</span> UUID.randomUUID().toString()+extension;</span><br><span class="line">            <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> aliOssUtil.upload(file.getBytes(), ObjectName);</span><br><span class="line">            <span class="keyword">return</span> Result.success(filePath);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中所用到的工具类(有阿里云官方代码改造而来)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOssUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要为自己获取到的</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objectName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(<span class="type">byte</span>[] bytes, String objectName)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">        <span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建PutObject请求。</span></span><br><span class="line">            ossClient.putObject(bucketName, objectName, <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OSSException oe) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught an OSSException, which means your request made it to OSS, &quot;</span></span><br><span class="line">                    + <span class="string">&quot;but was rejected with an error response for some reason.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Message:&quot;</span> + oe.getErrorMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Code:&quot;</span> + oe.getErrorCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;Request ID:&quot;</span> + oe.getRequestId());</span><br><span class="line">            System.out.println(<span class="string">&quot;Host ID:&quot;</span> + oe.getHostId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException ce) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught an ClientException, which means the client encountered &quot;</span></span><br><span class="line">                    + <span class="string">&quot;a serious internal problem while trying to communicate with OSS, &quot;</span></span><br><span class="line">                    + <span class="string">&quot;such as not being able to access the network.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Message:&quot;</span> + ce.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ossClient != <span class="literal">null</span>) &#123;</span><br><span class="line">                ossClient.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件访问路径规则 https://BucketName.Endpoint/ObjectName</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;https://&quot;</span>);</span><br><span class="line">        stringBuilder</span><br><span class="line">                .append(bucketName)</span><br><span class="line">                .append(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">                .append(endpoint)</span><br><span class="line">                .append(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">                .append(objectName);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;文件上传到:&#123;&#125;&quot;</span>, stringBuilder.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
