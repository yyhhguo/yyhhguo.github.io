<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux学习</title>
      <link href="/2024/05/19/linux%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/05/19/linux%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul><li><p>linux操作系统的目录结构</p><p>Linux只有一个顶级目录，称之为：根目录</p><p>Windows系统有多个顶级目录，即各个盘符</p></li><li><p>&#x2F;在Linux系统中表示</p><p>出现在开头的<code>/</code>表示根目录，出现在后面的<code>/</code>表示层级关系</p></li></ul><h2 id="Linux命令入门"><a href="#Linux命令入门" class="headerlink" title="Linux命令入门"></a>Linux命令入门</h2><h3 id="Linux命令基础"><a href="#Linux命令基础" class="headerlink" title="Linux命令基础"></a>Linux命令基础</h3><h4 id="什么是命令，命令行"><a href="#什么是命令，命令行" class="headerlink" title="什么是命令，命令行"></a>什么是命令，命令行</h4><ul><li>命令：即Linux操作指令，是系统内置的程序，可以以字符化的形式去使用</li><li>命令行：即Linux终端，可以提供字符化的操作页面供命令执行</li></ul><h4 id="Linux命令通用格式"><a href="#Linux命令通用格式" class="headerlink" title="Linux命令通用格式"></a>Linux命令通用格式</h4><p><code>command[-options][parameter]</code></p><ul><li>命令本体，即命令本身</li><li>可选选项，控制命令的行为细节</li><li>可选参数，控制命令的指向目标</li></ul><h4 id="ls命令入门"><a href="#ls命令入门" class="headerlink" title="ls命令入门"></a>ls命令入门</h4><ul><li>ls命令作用：在命令行中，以平埔的形式，展示当前工作目录（默认Home目录）下的内容</li><li>Home目录：每一个用户在Linux系统的专属目录：默认在&#x2F;home&#x2F;用户名</li><li>当前工作目录：Linux命令行在执行命令的时候，需要一个工作目录，打开命令行程序（终端）默认设置目录在Home目录</li></ul><h4 id="ls命令的参数和选项"><a href="#ls命令的参数和选项" class="headerlink" title="ls命令的参数和选项"></a>ls命令的参数和选项</h4><ul><li><p>ls命令参数的作用：可以查看指定文件夹的内容，如果不给定参数，则查看当前工作目录下的内容</p></li><li><p>ls命令的选项：</p><p>（1）-a选项，可以展示出隐藏的内容</p><p>（2）-l选项，以列表的形式展示内容，并展示更多细节</p><p>（3）-h选项，需要和-l选项搭配使用，可以显示文件的大小单位</p></li><li><p>命令的选项组合使用</p><p>命令的选项是可以组合的，比如<code>ls -lah</code>，等同于<code>ls -a -l -h</code></p></li></ul><h3 id="目录切换相关命令"><a href="#目录切换相关命令" class="headerlink" title="目录切换相关命令"></a>目录切换相关命令</h3><h4 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h4><p>用来切换当前的工作目录，语法是</p><p><code>cd [Linux路径]</code></p><ul><li>没有选项，只有参数，表示目标路径</li><li>使用参数，切换到目标路径</li><li>不使用参数，切换工作目录到当前用户的HOME</li></ul><h4 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h4><ul><li>pwd命令：没有选项，没有参数，直接使用即可</li><li>作用：输出当前的工作目录</li></ul><h4 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h4><ul><li>绝对路径：以根目录为起点，描述路径的方式，路径以<code>/</code>开头</li><li>相对路径：以当前目录做起点，描述路径的方式，路径不需以<code>/</code>开头</li></ul><h4 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符"></a>特殊路径符</h4><ul><li><code>.</code>表示当前目录</li><li><code>..</code>表示上一级目录</li><li><code>~</code>表示用户的HOME目录</li></ul><h3 id="创建目录命令"><a href="#创建目录命令" class="headerlink" title="创建目录命令"></a>创建目录命令</h3><h4 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h4><ul><li>mkdir用以创建新的目录</li><li>语法：<code>mkdir  [-p]  Linux路径</code></li><li>参数必填，表示要创建的目录的路径，相对，绝对路径均可使用</li><li>p选项可选，表示自动创建不存在的父目录，适用于创建连续多层级的目录</li></ul><h3 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h3><h4 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h4><ul><li>用于创建一个新的文件</li><li>语法 <code>touch Linux路径</code></li><li>参数必填，表示要创建文件的路径</li></ul><h4 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h4><ul><li>用于查看文件内容</li><li>语法 <code>cat Linux路径</code></li><li>参数必填，表示要查看文件的路径</li></ul><h4 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h4><ul><li>用于查看文件内容，课翻页查看</li><li>语法 <code>more Linux路径</code></li><li>参数必填，表示要查看文件的路径</li><li>使用空格翻页，使用p退出查看</li></ul><h4 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h4><ul><li>用于复制文件或文件夹</li><li>语法 <code>cp [-r] 参数1 参数2</code></li><li>参数1和参数2分别表示被复制的文件或文件夹和复制要去的地方</li><li>选项可填，带上表示复制的是一个文件夹</li></ul><h4 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h4><ul><li>用于移动文件</li><li>语法 <code>mv 参数1 参数2</code></li><li>参数1表示被移动的文件或文件夹，参数2表示移动要去的地方，如果不存在则对参数1进行改名</li></ul><h4 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h4><ul><li>用于删除文件或文件夹</li><li>语法 <code>rm [-r -f] 参数1 参数2 ......</code></li><li>-r选项，可选，表示文件夹删除    -f，可选，表示强制删除（一般用于root用户）</li><li>参数表示被删除的文件或文件夹路径，可支持批量删，也支持通配符*，可用于模糊匹配</li></ul><h3 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h3><h4 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h4><ul><li>查找命令的程序文件</li><li>语法 <code>which 要查找的命令</code></li></ul><h4 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h4><p>（1）按名称查找</p><p>语法：<code>find 起始路径 -name &quot;被查找文件名&quot;</code></p><ul><li>支持通配符<code>*</code></li></ul><p>(2)按文件大小查找</p><p>语法：<code>find 起始路径 -size +/-  n[KMG]</code></p><ul><li>+&#x2F;-代表大于或小于</li><li>n代表数字</li><li>[KMG]是大小的单位</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find /user -size + 100 M</span><br><span class="line"><span class="comment">#/user目录内大于100M的文件</span></span><br></pre></td></tr></table></figure><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><h4 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h4><ul><li>从文件中通过关键词过滤文件行</li><li>语法：<code>grep  [-n] 关键字  文件路径</code></li><li>选项-n，可选，表示在结果中匹配的行的行号</li><li>关键字必填，表示要过滤的关键字，建议用” “包围起来</li><li>文件路径必填，表示要过滤的内容的文件路径，可通过管道符输入。</li></ul><h4 id="WC命令"><a href="#WC命令" class="headerlink" title="WC命令"></a>WC命令</h4><ul><li>命令统计文件的行数，单词数，字节数，字符数</li><li>语法：<code>wc [-c -m -l -w] 文件路径</code></li><li>不带选项默认统计行数，单词数，字节数</li><li>-c字节数   -m字符数   -l行数   -w单词数</li><li>参数，被统计的文件路径，可通过管道符输入</li></ul><h4 id="管道符"><a href="#管道符" class="headerlink" title="管道符|"></a>管道符<code>|</code></h4><p>将管道左边的结果作为右边的输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> text.txt | grep hello | <span class="built_in">wc</span> -l</span><br><span class="line"><span class="comment">#统计text.txt中带有hello关键字的有几行</span></span><br></pre></td></tr></table></figure><h4 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h4><ul><li>可以使用echo命令在命令行输出指定内容</li><li>语法：<code>echo 输出内容</code></li><li>无需选项，只需一个参数，表示要输出的内容，可用” “包围</li></ul><h4 id="反引号符"><a href="#反引号符" class="headerlink" title="&#96;&#96; &#96;反引号符"></a>&#96;&#96; &#96;反引号符</h4><p>被&#96;&#96; &#96;包围的内容，会被当做命令执行，而非普通字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">pwd</span>`</span><br><span class="line"><span class="comment">#不会输出`pwd`，而会输出当前工作目录</span></span><br></pre></td></tr></table></figure><h4 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h4><ul><li><code>&gt;</code>，将左侧命令的结果，覆盖写入符号右边的指定文件中</li><li><code>&gt;&gt;</code>，将左侧命令的结果，追加写入符号右边的指定文件中</li></ul><h4 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h4><ul><li>查看文件尾部的内容，并可以持续追踪</li><li>语法：<code>tail [-f  -num] Linux路径</code></li><li><code>-f</code>:持续追踪，<code>-num</code>，查看尾部多少行，默认查看尾部10行</li></ul><h3 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>vi\vim编辑器，就是命令行模式下的文本编辑器，用来编辑文件</li><li>vim是vi的升级版，一般用vim即可，包含vi的全部功能</li></ul><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><p><code>vi 文件路径</code>    <code>vim 文件路径</code></p><h4 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h4><ul><li>命令模式：默认模式，可以通过键盘快捷键控制文件内容</li><li>输入模式：通过命令模式输入<code>i</code>进入，可以输入内容进行编辑，按<code>esc</code>退回命令模式</li><li>底线命令模式：通过命令模式进入，可以对文件进行保存，关闭操作，输入<code>wq</code>退出</li></ul><h2 id="Linux用户和权限"><a href="#Linux用户和权限" class="headerlink" title="Linux用户和权限"></a>Linux用户和权限</h2><h3 id="Linux的root用户"><a href="#Linux的root用户" class="headerlink" title="Linux的root用户"></a>Linux的root用户</h3><p>Linux系统的超级用户管理员是：root</p><h4 id="su命令"><a href="#su命令" class="headerlink" title="su命令"></a>su命令</h4><ul><li>可以切换用户，语法：<code>su  [-]  [用户名]</code></li><li><code>-</code>表示切换后带上环境变量，建议带上</li><li>用户可以省略，省略默认切换到root</li></ul><h4 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h4><ul><li><p>可以让一条普通命令带有root权限，语法：<code>sudo  其他命令</code></p></li><li><p>需要以root用户执行<code>visudo</code>命令，增加相关的配置方法即可让普通用户有<code>sudo</code>命令的执行权限</p><p>在该文件的最后一行加入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名  ALL=(ALL)    NOPASSWD: ALL</span><br></pre></td></tr></table></figure></li></ul><h3 id="用户-用户组管理"><a href="#用户-用户组管理" class="headerlink" title="用户 用户组管理"></a>用户 用户组管理</h3><h4 id="Linux用户管理模式"><a href="#Linux用户管理模式" class="headerlink" title="Linux用户管理模式"></a>Linux用户管理模式</h4><ul><li>Linux可以支持多用户，多用户组，用户加入多个组</li><li>Linux权限管控的单元是用户级别和用户组级别</li></ul><h4 id="用户-用户组相关命令"><a href="#用户-用户组相关命令" class="headerlink" title="用户  用户组相关命令"></a>用户  用户组相关命令</h4><ul><li><code>groupadd</code>添加用户组，<code>groupdel</code>删除用户组</li><li><code>useradd</code>添加用户，<code>userdel</code>删除用户</li><li><code>usermod -aG 用户组 用户名</code>修改用户组，将指定用户加入到用户组，<code>id</code>命令查看用户信息</li><li><code>getent password</code>查看系统全部用户信息</li><li><code>getent group</code>查看系统全部组信息</li></ul><h3 id="查看权限控制"><a href="#查看权限控制" class="headerlink" title="查看权限控制"></a>查看权限控制</h3><h4 id="ls-l列出的权限信息"><a href="#ls-l列出的权限信息" class="headerlink" title="ls -l列出的权限信息"></a>ls -l列出的权限信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x. 2 yh yh 6 5月  19  02:34 Desktop</span><br><span class="line"><span class="comment">#1            #2 #3</span></span><br></pre></td></tr></table></figure><ul><li>序号1，表示文件，文件夹的控制信息</li><li>序号2，表示文件，文件夹的所属用户</li><li>序号3，表示文件，文件夹所属用户组</li></ul><h4 id="权限细节"><a href="#权限细节" class="headerlink" title="权限细节"></a>权限细节</h4><table><thead><tr><th>文件类型（1）</th><th>所有者权限（2-4）</th><th>同组用户权限（5-7）</th><th>其他用户权限（8-10）</th></tr></thead><tbody><tr><td><code>-</code>或<code>d</code>或<code>l</code></td><td>(<code>r</code>或<code>-</code>)</td><td>(<code>w</code>或<code>-</code>)</td><td>(<code>x</code>或<code>-</code>)</td></tr></tbody></table><p>文件类型：<code>-</code>表示文件，<code>d</code>表示文件夹，<code>l</code>表示软连接</p><h4 id="rwx分别代表什么"><a href="#rwx分别代表什么" class="headerlink" title="rwx分别代表什么"></a>rwx分别代表什么</h4><ul><li><code>r</code>表示可以查看内容</li><li><code>w</code>表示可以修改此文件，针对文件夹即可以创建，修改，删除等操作</li><li><code>x</code>表示可以将文件作为程序执行，针对文件夹，则表示可以将工作目录更改到此文件夹，即<code>cd</code>进入</li><li><code>-</code>即代表不包含该类权限</li></ul><h3 id="修改权限控制-chmod"><a href="#修改权限控制-chmod" class="headerlink" title="修改权限控制-chmod"></a>修改权限控制-chmod</h3><h4 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h4><ul><li><p>修改文件，文件夹的权限细节</p></li><li><p>只能是文件，文件夹的所属用户或root有权修改</p></li><li><p>语法：<code>chmod [-R] 权限  文件或文件夹</code></p></li><li><p>选项<code>-R</code>，对文件夹内的内容应用同样的规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R u=rwx,g=rx,o=x hello.txt</span><br><span class="line"><span class="comment">#-rwxr-x--x</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="权限的数字序号"><a href="#权限的数字序号" class="headerlink" title="权限的数字序号"></a>权限的数字序号</h4><ul><li><p><code>r</code>代表4，<code>w</code>代表2，<code>x</code>代表1</p></li><li><p>通过相应的数字整合即可得到相应权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R 761 hello.txt</span><br><span class="line"><span class="comment">#-rwxrw---x</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="修改权限控制-chown"><a href="#修改权限控制-chown" class="headerlink" title="修改权限控制-chown"></a>修改权限控制-chown</h3><h4 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h4><ul><li><p>修改文件，文件夹的所属用户和用户组</p></li><li><p>此命令只适用于<code>root</code>用户</p></li><li><p>语法：<code>chown [-R] [用户] [:] [用户组] 文件或文件夹</code></p></li><li><p>选项<code>-R</code>，对文件夹内的内容应用同样的规则</p></li><li><p>选项用户和用户组分别对应修改所属用户和用户组</p></li><li><p><code>:</code>用于分隔用户和用户组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> root hello.txt</span><br><span class="line"><span class="comment">#将文件的用户修改为root</span></span><br><span class="line"><span class="built_in">chown</span> :root hello.txt</span><br><span class="line"><span class="comment">#将文件的用户组修改为root</span></span><br><span class="line"><span class="built_in">chown</span> root:root hello.txt</span><br><span class="line"><span class="comment">#将文件的用户和用户组都修改为root</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis-plus</title>
      <link href="/2024/05/18/Mybatis-plus/"/>
      <url>/2024/05/18/Mybatis-plus/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>MyBatis-Plus</code> 是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。它提供了很多实用的功能，使得开发者在使用 MyBatis 时能够更加方便和高效。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul><li><p>@TableName: 指定表名及全局配置</p></li><li><p>@TableId：指定Id字段及相关配置</p><p>IdType的类型：</p><p>(1)AUTO：自增长，由数据库生成id    </p><p>(2) ASSIGN_ID：通过雪花算法，由mp生成id    </p><p>(3)INPUT：通过用户输入id</p></li><li><p>@TableFiled：指定普通字段及相关配置</p><p>使用场景</p><ul><li>成员变量与数据库名称不一致</li><li>成员变量以is开头，且是布尔值</li><li>成员变量与数据库关键词冲突</li><li>成员变量不是数据库字段</li></ul></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="comment">#别名扫描包</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">&quot;classpath*:/mapper/**/*.xml&quot;</span> <span class="comment">#mapper.xml文件地址</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">cache-enabled:</span> <span class="literal">false</span> <span class="comment">#是否开启二级缓存</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">ASSIGN_ID</span> <span class="comment">#id为雪花算法生成</span></span><br><span class="line">      <span class="attr">update-strategy:</span> <span class="string">not_null</span> <span class="comment">#更新策略：只更新非空字段</span></span><br></pre></td></tr></table></figure><h3 id="条件构造器用法"><a href="#条件构造器用法" class="headerlink" title="条件构造器用法"></a>条件构造器用法</h3><ul><li>QueryWrapper和LambdaQueryWrapper通常用来构建select，delete，update的where条件部分</li><li>UpdateWrapper和LambdaUpdateWrapper通常只有在set语句比较特殊时才使用</li><li>尽量使用LambdaQueryWrapper和LambdaUpdateWrapper，避免硬编码(例User::getId)</li></ul><h3 id="自定义sql"><a href="#自定义sql" class="headerlink" title="自定义sql"></a>自定义sql</h3><p>由于mp擅长的事where条件的编写，但不擅长select，set等处的编写，此时若在构造器处去拼相应的代码，那么就需要在业务层去构建sql语句，这显然不符合大多数企业的开发规范，此时则需要自定义sql</p><ul><li><p>基于Wrapper构建Where条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="type">long</span>&gt; ids = List.of(<span class="number">1L</span>,<span class="number">2L</span>,<span class="number">4L</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="comment">//构建条件</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;().in(User::getId,ids);</span><br><span class="line"><span class="comment">//自定义sql方法调用</span></span><br><span class="line">usermapper.updateBalanceByIds(wrapper,amount);</span><br></pre></td></tr></table></figure></li><li><p>在mapper方法参数中用param注解声明wrapper变量名称，必须是ew</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update(&quot;update tb_user set balance = balance-#&#123;amount&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">updateBalanceByIds</span><span class="params">(<span class="meta">@param(&quot;ew&quot;)</span> LambdaQueryWrapper&lt;User&gt; wrapper,<span class="meta">@param(&quot;amount&quot;)</span> <span class="type">int</span> amount)</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="MP的Service接口使用"><a href="#MP的Service接口使用" class="headerlink" title="MP的Service接口使用"></a>MP的Service接口使用</h3><ul><li><p>自定义Service接口继承IService接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt;&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义service实现类，实现自定义接口并继承ServiceImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper,User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h3><p>在实际业务中，用户删除的一些数据并不是真的删除了，而是采用逻辑删除，例如，用户将购物车中的商品取消，但此时并不是真的删除了这一条数据，因为这些数据对于后期的数据统计非常重要，所以实际开发中，通常会使用一个标记来确定此商品是否真的被删除</p><p>MP提供了逻辑删除的功能，无需改变方法调用的方式，而是在底层自动帮我们修改CRUD语句，我们要做的就是在yml文件中配置逻辑删除的字段名称和值即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">   <span class="attr">db-config:</span></span><br><span class="line">     <span class="attr">logic-delete-filed:</span> <span class="string">deleted</span> <span class="comment">#全局删除的实体字段名，字段类型可以是boolean,integer</span></span><br><span class="line">     <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment">#逻辑已删除值（默认为1）</span></span><br><span class="line">     <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment">#逻辑未删除值（默认为0）</span></span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>逻辑删除的问题</p><ul><li>会导致数据库表垃圾数据越来越多，影响查询效率</li><li>SQL中全部需要对逻辑字段做判断，影响查询效率</li></ul><p>因此，如果数据不能删除，可以采用将数据迁移到其他表的方法</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端相关笔记</title>
      <link href="/2024/05/13/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/05/13/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="路由器："><a href="#路由器：" class="headerlink" title="路由器："></a>路由器：</h2><ul><li><p>路由组成</p><ul><li>VueRouter：路由器，根据路由请求在路由视图上动态渲染对应组件。</li><li><router-link>：路由链接组件，浏览器会解析成超链接。</li><li><router-view>：路由器组件，用来展示与路由路径匹配的路由组件，可以将其类比为页面中的占位。</li></ul></li><li><p>相关流程</p><p>点击<router-link>发出路由请求到VueRouter，VueRouter根据路由路径的不同去渲染对应的组件，渲染到<router-view>的这个位置</p></li></ul><h3 id="安装路由"><a href="#安装路由" class="headerlink" title="安装路由"></a>安装路由</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router@3.5.1</span><br></pre></td></tr></table></figure><h3 id="router代码"><a href="#router代码" class="headerlink" title="router代码"></a>router代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Manage&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>( <span class="string">&#x27;../views/Manage.vue&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,<span class="comment">//组件路径</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">    <span class="comment">// route level code-splitting</span></span><br><span class="line">    <span class="comment">// this generates a separate chunk (about.[hash].js) for this route</span></span><br><span class="line">    <span class="comment">// which is lazy-loaded when the route is visited.</span></span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../views/AboutView.vue&#x27;</span>),<span class="comment">//组件所在位置</span></span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;子路由路径&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: <span class="string">&#x27;子路由组件&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">base</span>: process.<span class="property">env</span>.<span class="property">BASE_URL</span>,</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>mode</code> 选项定义了路由的模式。Vue Router 提供了两种模式：</p><ul><li>* <code>&#39;hash&#39;</code>：这是默认模式。在这种模式下，URL 会包含一个 <code>#</code> 符号，如 <code>http://example.com/#/about</code>。这种方式的好处是它对服务器没有特殊的要求，因为所有的 URL 都会发送到同一个 HTML 文件（通常是 <code>index.html</code>），然后由 Vue Router 接管。</li></ul><ul><li><code>&#39;history&#39;</code>：在这种模式下，URL 会看起来像正常的 URL，没有 <code>#</code> 符号，如 <code>http://example.com/about</code>。但是，为了正常工作，服务器需要配置以支持这种方式。当访问这样的 URL 时，服务器需要返回与 <code>index.html</code> 相同的 HTML 文件，然后由 Vue Router 接管并显示正确的视图。</li></ul><h2 id="Vuex介绍"><a href="#Vuex介绍" class="headerlink" title="Vuex介绍"></a>Vuex介绍</h2><ul><li><p>vuex是一个专门为vue.js应用程序开发的状态管理库</p></li><li><p>vuex可以在多个组件内共享数据，并且共享的数据时响应式的，及数据的变更能及时渲染到模板</p></li><li><p>vuex采用集中式存储所有组件的状态，更易管理，更规范</p></li></ul><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>ajax是一种异步无刷新技术</p><ul><li>异步：无需等待服务器返回结果，便可以执行其他程序</li><li>无刷新：做了一些操作后，页面不会刷新，依然停留在当前位置</li></ul><h3 id="同步异步对比"><a href="#同步异步对比" class="headerlink" title="同步异步对比"></a>同步异步对比</h3><p>在传统的Web应用中，当浏览器向服务器发送请求时，浏览器会等待服务器的响应，同时整个页面会被“锁定”，用户无法进行其他操作，直到服务器响应返回并处理完毕，页面才会重新“解锁”。这种方式被称为同步</p><p>在使用Ajax技术时，浏览器向服务器发送请求后，<strong>不会等待服务器的响应</strong>，而是立即返回并继续执行后续的代码。同时，浏览器会设置一个回调函数（Callback Function）来处理服务器的响应。当服务器响应返回时，浏览器会调用这个回调函数来处理响应数据，而不会阻塞用户的其他操作。这就是异步处理的方式。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在搜索引擎中，会有自动补全功能，每输入一个或几个字符，浏览器会发送一个ajax请求到服务器获取相关联想数据，如果是非异步请求，则发送请求的这一段时间，用户无法进行其他操作，会大大降低用户体验，反之，使用异步，<strong>发送请求后，浏览器不会等待服务器的响应</strong>，而是立即返回并继续执行后续的代码（如允许用户继续输入或执行其他操作）。其中的无刷新技术也可以在浏览器接到响应后不刷新整个页面，而是使用js结合DOM操作动态的将相关数据显示出来。</p><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><p>由于原生ajax过于繁杂，所以应用较少，这里介绍使用axios包装ajax请求的示例</p><h4 id="安装-axios"><a href="#安装-axios" class="headerlink" title="安装 axios"></a>安装 axios</h4><p>如果你还没有安装 <code>axios</code>，你可以使用 npm 或 yarn 来安装它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install axios  </span><br><span class="line"><span class="comment"># 或者  </span></span><br><span class="line">yarn add axios</span><br></pre></td></tr></table></figure><h4 id="使用-axios-发送-GET-请求"><a href="#使用-axios-发送-GET-请求" class="headerlink" title="使用 axios 发送 GET 请求"></a>使用 axios 发送 GET 请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 axios  </span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 发送 GET 请求到 API 地址  </span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>)  </span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;  </span><br><span class="line">    <span class="comment">// 请求成功时，处理响应数据  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);  </span><br><span class="line">  &#125;)  </span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;  </span><br><span class="line">    <span class="comment">// 请求失败时，处理错误  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);  </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="使用-axios-发送-POST-请求"><a href="#使用-axios-发送-POST-请求" class="headerlink" title="使用 axios 发送 POST 请求"></a>使用 axios 发送 POST 请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 axios  </span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 发送 POST 请求到 API 地址，并携带一些数据  </span></span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;https://api.example.com/submit&#x27;</span>, &#123;  </span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,  </span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span>  </span><br><span class="line">  &#125;)  </span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;  </span><br><span class="line">    <span class="comment">// 请求成功时，处理响应数据  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);  </span><br><span class="line">  &#125;)  </span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;  </span><br><span class="line">    <span class="comment">// 请求失败时，处理错误  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);  </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="使用-async-await-简化代码"><a href="#使用-async-await-简化代码" class="headerlink" title="使用 async&#x2F;await 简化代码"></a>使用 async&#x2F;await 简化代码</h4><p>如果你正在使用支持 <code>async/await</code> 的环境（如较新版本的 JavaScript 或 TypeScript），你可以进一步简化你的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 axios  </span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="comment">// 使用 async/await 发送 GET 请求  </span></span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>);  </span><br><span class="line">    <span class="comment">// 请求成功时，直接处理响应数据  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);  </span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;  </span><br><span class="line">    <span class="comment">// 请求失败时，处理错误  </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 调用函数  </span></span><br><span class="line"><span class="title function_">fetchData</span>();</span><br></pre></td></tr></table></figure><p>使用 <code>axios</code> 可以让你更加专注于处理请求和响应数据，而不是编写复杂的错误处理和异步代码</p><h2 id="typeScript介绍"><a href="#typeScript介绍" class="headerlink" title="typeScript介绍"></a>typeScript介绍</h2><ul><li><p>为js的超集，js有的他都有，添加了类型补充</p><p>添加类型补充的好处</p><ul><li>TS属于静态类型编程语言，JS属于动态类型编程语言</li><li>静态类在编译期做类型检查，动态类在执行期做类型检查</li><li>则TS可以更早地发现问题</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring基础学习</title>
      <link href="/2024/05/10/spring%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/05/10/spring%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringFrameWork"><a href="#SpringFrameWork" class="headerlink" title="SpringFrameWork"></a>SpringFrameWork</h2><p>控制反转（IOC）和面向切面编程（AOP）是SpringFrameWork中最重要的两个概念</p><h3 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>IOC将对象的创建，组装和管理的控制权从应用程序代码中反转到spring的IOC容器中，由IOC容器的ApplicationContext，</p><p>实现对象的自动装配和依赖注入。</p><ul><li>控制反转（IOC,Inversion of Control）控制指的是控制对象的创建过程，反转是反转创建对象的主体由程序员转化为容器， 在spring中容器是一个单例工厂，里面的每一个对象称之为bean，我们只需要在外部创建一个bean的构建过程，真正的创建由容器负责，在启动时期bean便完成了实例化</li></ul><h4 id="Bean的装配流程"><a href="#Bean的装配流程" class="headerlink" title="Bean的装配流程"></a>Bean的装配流程</h4><p><img src="https://image.itbaima.cn/markdown/2022/12/17/Un6qjPci2uvkL5X.png"></p><p><strong>对bean的管理都是依靠BeanFactory进行，可以通过BeanFactory对Bean进行生产和管理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();  <span class="comment">//这是BeanFactory的一个默认实现类</span></span><br><span class="line">     <span class="type">BeanDefinition</span> <span class="variable">definition</span> <span class="operator">=</span> BeanDefinitionBuilder   <span class="comment">//使用BeanDefinitionBuilder快速创建Bean定义</span></span><br><span class="line">            .rootBeanDefinition(Student.class)   <span class="comment">//Bean的类型</span></span><br><span class="line">            .setScope(<span class="string">&quot;prototype&quot;</span>)    <span class="comment">//设置作用域为原型模式</span></span><br><span class="line">            .getBeanDefinition();     <span class="comment">//生成此Bean定义</span></span><br><span class="line">    <span class="comment">//相当于实在xml文件中去注册bean</span></span><br><span class="line">    factory.registerBeanDefinition(<span class="string">&quot;hello&quot;</span>, definition);   <span class="comment">//向工厂注册Bean此定义，并设定Bean的名称</span></span><br><span class="line">    System.out.println(<span class="string">&quot;获取Bean对象：&quot;</span>+factory.getBean(<span class="string">&quot;hello&quot;</span>));  <span class="comment">//我们可以直接找工厂获取Bean对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BeanDefinition</strong>是Spring框架中的一个核心概念，它描述了Bean实例的属性和行为，并提供了创建和管理Bean实例的基础信息。BeanDefinition接口定义了一个Bean的元数据，包含了用于创建Bean对象实例的所有必要信息，如Bean的类名、作用域（如singleton或prototype等）、初始化方法、销毁方法、依赖项、属性值等。</p><h5 id="BeanDefinition有多种配置方式"><a href="#BeanDefinition有多种配置方式" class="headerlink" title="BeanDefinition有多种配置方式"></a>BeanDefinition有多种配置方式</h5><ul><li>配置文件配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.test.bean.Student&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注解配置</li></ul><p>使用注解则更为方便，通过@Service,@Controller等便可声明为bean对象，在配置类中加入@componentScan就可以将其加入到IOC容器中进行管理，配置类中@Bean注解的方法是用来实例化并注册Bean到Spring应用上下文中的，Bean的本质还是@Service等注解的这些类。</p><h5 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;test.xml&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) context.getBean(<span class="string">&quot;student&quot;</span>);   <span class="comment">//使用getBean方法来获取对应的对象（Bean）</span></span><br><span class="line">    student.hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationContext时IOC容器中的核心接口，是BeanFactory的子接口，相较于BeanFactory有更丰富的功能和更好的性能，负责实例化，配置和管理Bean对象，以及建立这些对象间的依赖关系，当启动Spring项目时，他会创建一个ApplicationContext的实例，然后由他负责初始化和配置应用中的所有对象</p><p>现在，我们就已经知道，Bean实际上是一开始通过BeanDefinitionReader进行扫描，然后将所有Bean以BeanDefinition对象的形式注册到对应的BeanFactory中进行集中管理，而我们使用的ApplicationContext实际上内部就有一个BeanFactory在进行Bean管理，这样容器才拥有了最基本的Bean管理功能。</p><h4 id="使用IOC容器管理的好处"><a href="#使用IOC容器管理的好处" class="headerlink" title="使用IOC容器管理的好处"></a>使用IOC容器管理的好处</h4><ul><li><p>降低代码耦合度</p><p>如果不使用IOC容器管理，则两个相互依赖的类则需要手动创建出实例，如果其中一个类需要改变，则需要改变的大量代码，使用IOC容器后，则不再创建实例，而是声明需要的依赖，由容器负责在运行时注入正确的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 耦合度低的UserService示例（使用接口）  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 声明依赖，但不创建实例  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 通过构造函数注入依赖  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserRepository userRepository)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ... 其他业务方法  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// UserRepository接口  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> &#123;  </span><br><span class="line">    <span class="comment">// ... 定义方法  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// UserRepository的具体实现  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseUserRepository</span> <span class="keyword">implements</span> <span class="title class_">UserRepository</span> &#123;  </span><br><span class="line">    <span class="comment">// ... 实现方法  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 另一个UserRepository的实现（比如API调用）  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiUserRepository</span> <span class="keyword">implements</span> <span class="title class_">UserRepository</span> &#123;  </span><br><span class="line">    <span class="comment">// ... 实现方法  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p> 在这个例子中，<code>UserService</code>只依赖于<code>UserRepository</code>接口，而不是具体的实现类。这意味着我们可以轻松地替换<code>UserRepository</code>的实现，而无需修改<code>UserService</code>的代码。只需在配置文件中修改相关的代码</p><ul><li><p>安全性</p><p>在高并发情况下，如果每一步都需要new一个对象，则会增大对内存的压力，而IOC容器为单例模式，每次只需从缓存中获取，这样内存抖动不会太严重，保证程序的可靠性稳定性。</p></li></ul><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，旨在通过预编译方式和运行期间间动态代理实现程序功能的统一维护的一种技术。AOP 是对 OOP（Object-Oriented Programming，面向对象编程）的补充，用于处理系统中分布于各个模块的横切关注点（cross-cutting concerns），如日志、事务管理、安全等。这些横切关注点通常与业务逻辑无关，但会散落到各个模块中，导致代码难以维护。</p><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ol><li><strong>切面（Aspect）</strong>：切面是一个横切关注点的模块化，这个关注点可能会横切多个对象。切面用来封装横切关注点（cross-cutting concern）的代码，该代码直接影响了业务类代码的执行。</li><li><strong>连接点（Joinpoint）</strong>：是程序执行过程中某个特定的位置，例如方法执行前，方法执行后等，可以理解为终须中可能插入前面的地方</li><li><strong>通知（Advice）</strong>：在特定的连接点，AOP框架执行的动作。例如，一个方法调用前打印日志，就是一个通知。</li><li><strong>切点（Pointcut）</strong>：切点用于定义哪些连接点应该被拦截。</li></ol><p>通过切入点来匹配程序中的特定连接点，在这些连接点上执行通知，这种通知是在连接点前后执行，也可以将连接点包围起来。</p><p><strong>连接点和切点的差异</strong>：</p><ol><li><strong>定义范围</strong>：连接点是程序执行过程中的一个特定位置，是一个具体的点；而切点是一组连接点的集合，是一个更广泛的概念。</li><li><strong>作用对象</strong>：连接点是AOP可以插入额外代码或逻辑的地方，是AOP框架操作的对象；而切点则是用于指定哪些连接点需要被拦截并应用通知，是定义AOP操作范围的工具。</li><li><strong>使用方式</strong>：在AOP中，连接点通常不需要显式定义，而是由AOP框架在运行时自动识别和定位；而切点则需要显式定义，通过规则或表达式来指定需要拦截的连接点。</li></ol><p>总结来说，连接点和切点在AOP中各自扮演着不同的角色。连接点是AOP框架操作的具体位置，而切点则是用于定义AOP操作范围的工具，通过指定需要拦截的连接点来实现对程序的增强或修改。</p><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>在原始的springFramWork中，建立一个项目需要经过繁杂的依赖导入以及配置，依赖导入还经常会出现版本不匹配的问题，而SpringBoot通过其起步依赖和自动配置的特性就完美的解决了这两个问题，降低了学习成本，实现了开箱即用。</p><h3 id="启动流程（简化版）"><a href="#启动流程（简化版）" class="headerlink" title="启动流程（简化版）"></a>启动流程（简化版）</h3><ul><li>创建IOC容器  createApplicationContext(..)</li><li>加载源配置类  loadSourceClass(..)  源配置类通常是main方法所在的类，而且会被注解@SpringBootApplication所修饰，我们又称为主类。</li><li>加载并处理所有的配置类  processConfigurationClasses(..)   SpringBoot会自动找到所有配置类，然后加载处理他们。“自动配置”就属于其中的一环。</li><li>实例化所有的单例bean  instantiateSingletonBeans(..)   实例化所有的单例Bean。“依赖注入”和“自动装配”就属于其中的环节</li><li>启动web服务器</li></ul><h3 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h3><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ol><li><strong>简化配置</strong>：Spring Boot的起步依赖通过预定义和整合了常用的依赖项，极大地简化了项目的配置工作。例如，当你添加了<code>spring-boot-starter-web</code>依赖后，Spring Boot会自动配置内嵌的Web服务器、Spring MVC和其他相关组件，而无需你手动配置这些组件。</li><li><strong>快速启动</strong>：由于减少了手动配置的需要，开发者可以更快地启动和交付高质量的应用。你只需选择适合项目需求的起步依赖，Spring Boot就会自动为你处理底层的配置和依赖管理。</li><li><strong>一致性和可维护性</strong>：通过使用预定义的起步依赖，可以确保项目在不同环境和开发者之间具有一致性和可维护性。这些起步依赖都经过Spring Boot团队的精心选择和测试，以确保它们之间的兼容性和稳定性。</li><li><strong>减少错误</strong>：由于起步依赖已经处理了底层框架和库的配置和管理，因此可以减少因手动配置错误而导致的运行时问题。这有助于降低项目的风险和成本。</li><li><strong>易于扩展</strong>：虽然起步依赖为开发者提供了很多便利，但它们仍然是可扩展的。如果你需要添加或修改某个特定的依赖项，你可以很容易地在项目中添加或排除它。</li></ol><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>SpringBoot自动配置就是Spring容器启动后，一些配置类，bean对象就自动存入了IOC容器中，不需要我们手动去声明， 从而简化了开发，省去了繁杂的配置操作。</p><h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><ul><li>广义的配置类：被注解@Component直接或间接修饰的某个类，即我们常说的Spring组件，其中包括了@Configuration类</li><li>狭义的配置类：特指被注解@Configuration所修饰的某个类，又称@configuration类。</li></ul><p>如果没有特殊说明，我们说的配置类一般指广义的配置类，狭义的配置类我们一般称@Configuration类。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>从源配置类开始通过注解@ComponentScan和注解@Implort不断地递归遍历新的配置类，直到没有新的配置类被发现位置，得到的一个配置类集合，将配置类本身注册到IOC容器中，处理配置类中的@Bean方法，将其返回类型注册到IOC容器中，处理通过@Import导入的ImportBeanDefinitionRegistrar</p><p>我们的启动类上有<code>@SpringBootApplication</code></p><ul><li><p>子注解@SpringBootConfiguration，间接被@Configuration修饰，即启动类是一个源配置类</p></li><li><p>子注解@ComponentScan，对源配置类所在的Package进行组件扫描</p></li><li><p>子注解<code>@EnableAutoConfiguration</code>，最终导入一个<code>AutoConfigurationImportSelector</code>组件来实现自动配置</p></li><li><p>然后Spring通过实现的<code>ImportSelector</code>接口中的selectImports(..)返回一个字符串数组，内容就是扫描文件</p><p><code>META-INF/spring.factories</code>中的需要导入IOC容器中Bean的全类名，这其中还会根据这些自动配置类上的条件注解@Condition进行过滤，过滤出满足条件的自动配置类</p></li><li><p>从而得到这些自动配置类的<code>BeanDefinition</code></p></li><li><p>最后根据BeanDefinition实例化对象</p></li></ul><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><ul><li><p>@Import</p><p><code>@Import</code>注解是一个非常重要的注解，它允许你导入其他配置类、组件或配置，以便在当前的Spring上下文中使用。这个注解主要用于扩展Spring的配置和功能。</p><ul><li><p><strong>导入普通类</strong>：你可以使用@Import注解来导入一个普通类使之成为Bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(UserService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfig</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>导入配置类</strong>：你可以使用<code>@Import</code>注解来导入其他配置类，这样你就可以在一个配置类中组合多个配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@Import(AnotherConfig.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfig</span> &#123;  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>导入ImportSelector的实现</strong>：<code>ImportSelector</code>是一个接口，它允许你动态地选择并返回要导入的配置类。这对于根据条件或外部配置来加载不同的配置类特别有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfig</span> &#123;  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.example.AnotherConfig&quot;</span>&#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>导入ImportBeanDefinitionRegistrar的实现</strong>：<code>ImportBeanDefinitionRegistrar</code>接口允许你在运行时动态地注册bean定义。这给了你更多的灵活性，可以基于复杂的条件或外部输入来注册bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@Import(MyImportBeanDefinitionRegistrar.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfig</span> &#123;  </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;  </span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">rootBeanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(AnotherBean.class);  </span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;anotherBean&quot;</span>, rootBeanDefinition);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>苍穹外卖总结</title>
      <link href="/2024/05/04/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E6%80%BB%E7%BB%93/"/>
      <url>/2024/05/04/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Nginx是一个高性能的HTTP和反向代理服务器，它以其高并发处理能力和低内存占用而著称，在静态内容处理方面占有优势，因此实际生产中，经常与tomcat结合使用（tomcat为重量型服务器，处理高并发能力较弱），Nginx可以作为Tomcat的前端服务器，提供静态文件服务（如HTML、CSS、JavaScript等），并作为反向代理服务器将请求转发给Tomcat。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><p>提高访问速度</p><p>在单次请求和高并发请求环境下，Nginx都会比其他web服务器相应的更快，Nginx之所以有这么大的高并发处理能力，在于其采用了多进程和I&#x2F;O多路复用的底层实现</p></li><li><p>进行负载平衡</p><p>所谓负载平衡额就是把大量请求按照我们所指定的方式均衡的分配给集群中的每台服务器</p></li><li><p>保证后端服务安全</p><p>通过反向代理，隐藏真实的服务器IP地址</p></li><li><p>热部署</p><p>互联网项目要求7*24小时的进行提供服务，针对这一要求，Nginx提供了热部署功能，即可以在Nginx不停止的情况下，对Nginx进行文件升级，更新配置和更换日志文件。</p></li></ul><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><ol><li><strong>定义与原理</strong>：反向代理是以代理服务器来接受互联网上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给互联网上请求连接的客户端。此时，代理服务器对外就表现为一个服务器。</li><li><strong>主要功能</strong>：反向代理的主要功能包括负载均衡（分发流量到多台服务器上，保证服务的可用性和稳定性）、缓存（缓存动态或静态内容，减轻后端服务器的压力，提高页面访问速度）、安全性（隐藏真实的服务器IP地址，提高系统的安全性和隐私性）以及压缩（对页面进行压缩，减少页面的大小，提高页面的加载速度）。</li></ol><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal:"></a>ThreadLocal:</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>ThreadLocal并不是一个Thread(线程),而是Thread的一个局部变量</p><p>ThreadLocal为每一个线程提供单独一份的存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。换句话说，<code>ThreadLocal</code> 为每个线程提供了其自己的变量副本，因此每个线程都可以独立地改变自己的副本，而不会影响其他线程的副本。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li><p><strong>创建 ThreadLocal 实例</strong>：</p><p>使用 <code>ThreadLocal</code> 类，我们首先需要创建一个 <code>ThreadLocal</code> 实例，然后可以通过这个实例来访问线程局部变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></li><li><p><strong>设置和获取值</strong>：</p><ul><li><code>set(T value)</code>: 用于在当前线程中设置线程局部变量的值。</li><li><code>get()</code>: 用于获取当前线程中线程局部变量的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.set(<span class="string">&quot;Thread-A Value&quot;</span>);  </span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get(); <span class="comment">// 在当前线程中，这将返回 &quot;Thread-A Value&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>初始值</strong></p><p>默认情况下，如果没有为 <code>ThreadLocal</code> 设置值，那么调用 <code>get()</code> 方法将返回 <code>null</code>。但我们可以提供一个初始值，通过覆盖 <code>ThreadLocal</code> 的 <code>initialValue()</code> 方法来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">initialValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Initial Value&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>ThreadLocal</code> 可能会导致内存泄漏，因为它会在线程的生命周期内保持其值。如果线程长时间运行，并且 <code>ThreadLocal</code> 变量不再需要，但线程没有结束，那么这些变量占用的内存就无法被垃圾回收器回收。因此，在使用完 <code>ThreadLocal</code> 后，最好手动调用 <code>remove()</code> 方法来清除线程局部变量。</li><li><code>ThreadLocal</code> 不是解决并发问题的银弹。在大多数情况下，应该优先考虑使用同步机制（如 <code>synchronized</code> 或 <code>Lock</code>）来确保线程安全。<code>ThreadLocal</code> 只是在某些特定场景下提供了一种更优雅的解决方案。</li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis是一个基于内存的key-value结构数据库,与之对应的mysql是基于磁盘的数据库</p><p>由于基于内存存储，所以他的读写性能高，适用于储存热点数据（短时间大量访问数据）如热点商品，资讯，新闻</p><p>而mysql这种传统的数据库是基于磁盘IO进行数据读取，随着访问量的增大，这种读取方式劣势明显，于是redis应运而生</p><h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><ul><li>性能极高</li><li>数据类型丰富，单键值对最大支持512M大小的数据</li><li>简单易用，支持所有主流编程语言</li><li>支持数据持久化，主从复制，哨兵模式等高可用特性</li></ul><h3 id="springBoot整合redis"><a href="#springBoot整合redis" class="headerlink" title="springBoot整合redis"></a>springBoot整合redis</h3><h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">  <span class="comment">#Redis服务器地址</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.3</span></span><br><span class="line">    <span class="comment">#端口</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment">#使用几号数据库</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>starter已经给我们提供了两个默认的模板类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;RedisOperations.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisAutoConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">        name = &#123;&quot;redisTemplate&quot;&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">    <span class="keyword">public</span> StringRedisTemplate <span class="title function_">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>(redisConnectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需注入StringRedisTemplate来使用模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringBootTestApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; operations = template.opsForValue();</span><br><span class="line">        operations.set(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;xxxxx&quot;</span>);   <span class="comment">//设置值</span></span><br><span class="line">        System.out.println(operations.get(<span class="string">&quot;c&quot;</span>));   <span class="comment">//获取值</span></span><br><span class="line">      </span><br><span class="line">        template.delete(<span class="string">&quot;c&quot;</span>);    <span class="comment">//删除键</span></span><br><span class="line">        System.out.println(template.hasKey(<span class="string">&quot;c&quot;</span>));   <span class="comment">//判断是否包含键</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>WebSocket是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工通信——浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。</p><p>过程：客户端向服务端发送一个请求（HandShake）握手，服务端对客户端进行应答（Acknowledgement）,这样，客户端与服务端便建立好链接，双方可以进行双向通信。 </p><h3 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h3><ul><li><p>双向实时通信</p><p>允许在单个，长时间的链接上进行双向实时通信。在需要快速实时更新的应用程序里，比Http更加高效。</p></li><li><p>降低延迟</p><p>连接一旦建立便会保持开放，数据可以在客户端和服务器之间以比HTTP更低的延迟进行传输</p></li><li><p>更高效的资源利用</p><p>可以减少重复的请求和响应的开销，因为它的链接只需建立一次。</p><p>​</p></li></ul><p></p><h3 id="建立webSocket链接"><a href="#建立webSocket链接" class="headerlink" title="建立webSocket链接"></a>建立webSocket链接</h3><p>需要通过HTTP发送一次常规的Get请求，并在请求头中带上Upgrade，告诉服务器，要求从HTTP升级为webSocket，链接便建立成功，之后客户端和服务端就可以进行互相通信。</p><h3 id="使用代码"><a href="#使用代码" class="headerlink" title="使用代码"></a>使用代码</h3><h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServerEndpointExporter <span class="title function_">serverEndpointExporter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServerEndpointExporter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一旦ServerEndpointExporter被注册为bean，Spring就会扫描你的应用程序中的@ServerEndpoint注解，并自动配置  和注册相应的WebSocket端点。这使得你能够很容易地将WebSocket集成到Spring应用程序中。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WebSocket的服务"><a href="#WebSocket的服务" class="headerlink" title="WebSocket的服务"></a>WebSocket的服务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/ws/&#123;sid&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放会话对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Session&gt; sessionMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接建立成功调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session, <span class="meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端：&quot;</span> + sid + <span class="string">&quot;建立连接&quot;</span>);</span><br><span class="line">        sessionMap.put(sid, session);<span class="comment">//存放会话对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送过来的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, <span class="meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到来自客户端：&quot;</span> + sid + <span class="string">&quot;的信息:&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sid</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(<span class="meta">@PathParam(&quot;sid&quot;)</span> String sid)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接断开:&quot;</span> + sid);</span><br><span class="line">        sessionMap.remove(sid);<span class="comment">//移除该会话对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 群发</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendToAllClient</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        Collection&lt;Session&gt; sessions = sessionMap.values();<span class="comment">//获取所有客户端</span></span><br><span class="line">        <span class="keyword">for</span> (Session session : sessions) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//服务器向客户端发送消息</span></span><br><span class="line">                session.getBasicRemote().sendText(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HTTP</p><p>HTTP也是基于TCP的一种协议。请求响应模式，只有客户端向服务端发送请求，服务端才可以响应，不可颠倒，响应过后链接断开，故可称其为短链接</p><h2 id="JWT相关总结"><a href="#JWT相关总结" class="headerlink" title="JWT相关总结"></a>JWT相关总结</h2><p>（1）令牌的生成：由三部分组成，需要设置令牌的签名算法和签名密钥（保密，只能自己拥有，可随意设置）,过期时间，和主题数据（一般为用户id）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String secretKey, <span class="type">long</span> ttlMillis, Map&lt;String, Object&gt; claims)</span> &#123;</span><br><span class="line">    <span class="comment">// 指定签名的时候使用的签名算法，也就是header那部分</span></span><br><span class="line">    <span class="type">SignatureAlgorithm</span> <span class="variable">signatureAlgorithm</span> <span class="operator">=</span> SignatureAlgorithm.HS256;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成JWT的时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">expMillis</span> <span class="operator">=</span> System.currentTimeMillis() + ttlMillis;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(expMillis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置jwt的body</span></span><br><span class="line">    <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">            <span class="comment">// 如果有私有声明，一定要先设置这个自己创建的私有的声明，这个是给builder的claim赋值，一旦写在标准的声明赋值之后，就是覆盖了那些标准的声明的</span></span><br><span class="line">            .setClaims(claims)</span><br><span class="line">            <span class="comment">// 设置签名使用的签名算法和签名使用的秘钥</span></span><br><span class="line">            .signWith(signatureAlgorithm, secretKey.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">            <span class="comment">// 设置过期时间</span></span><br><span class="line">            .setExpiration(exp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> builder.compact();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 令牌的校验：即token的解密，通过JWTs的parser方法，设置密钥，以及需要解析的token，如果该过程为出异常，及说明令牌的校验成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWT</span><span class="params">(String secretKey, String token)</span> &#123;</span><br><span class="line">    <span class="comment">// 得到DefaultJwtParser</span></span><br><span class="line">    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">            <span class="comment">// 设置签名的秘钥</span></span><br><span class="line">            .setSigningKey(secretKey.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">            <span class="comment">// 设置需要解析的jwt</span></span><br><span class="line">            .parseClaimsJws(token).getBody();</span><br><span class="line">    <span class="keyword">return</span> claims;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两点通常封装在一个util类中，以便登陆时进行校验</p><p>(3)登录时所需要的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/employee&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeService employeeService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtProperties jwtProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> employeeLoginDTO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;EmployeeLoginVO&gt; <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> EmployeeLoginDTO employeeLoginDTO)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;员工登录：&#123;&#125;&quot;</span>, employeeLoginDTO);</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeService.login(employeeLoginDTO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//登录成功后，生成jwt令牌</span></span><br><span class="line">        Map&lt;String, Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        claims.put(JwtClaimsConstant.EMP_ID, employee.getId());</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtil.createJWT(</span><br><span class="line">                jwtProperties.getAdminSecretKey(),</span><br><span class="line">                jwtProperties.getAdminTtl(),</span><br><span class="line">                claims);</span><br><span class="line"></span><br><span class="line">        <span class="type">EmployeeLoginVO</span> <span class="variable">employeeLoginVO</span> <span class="operator">=</span> EmployeeLoginVO.builder()</span><br><span class="line">                .id(employee.getId())</span><br><span class="line">                .userName(employee.getUsername())</span><br><span class="line">                .name(employee.getName())</span><br><span class="line">                .token(token)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(employeeLoginVO);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>(4)拦截器的设置（interceptor）根据验证jwt来判断是否登录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtTokenAdminInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtProperties jwtProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验jwt</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//判断当前拦截到的是Controller的方法还是其他资源</span></span><br><span class="line">        <span class="keyword">if</span> (!(handler <span class="keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="comment">//当前拦截到的不是动态方法，直接放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、从请求头中获取令牌</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(jwtProperties.getAdminTokenName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、校验令牌</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;jwt校验:&#123;&#125;&quot;</span>, token);</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);</span><br><span class="line">            <span class="type">Long</span> <span class="variable">empId</span> <span class="operator">=</span> Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());</span><br><span class="line">            log.info(<span class="string">&quot;当前员工id：&quot;</span>, empId);</span><br><span class="line">            BaseContext.setCurrentId(empId);</span><br><span class="line">            <span class="comment">//3、通过，放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">//4、不通过，响应401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="消息推送的常见方式"><a href="#消息推送的常见方式" class="headerlink" title="消息推送的常见方式"></a>消息推送的常见方式</h2><p>（1）轮询：浏览器以指定的时间间隔向服务器发送HTTP请求，服务器实时返回数据给浏览器</p><p>   缺点：1-由于定时发送请求，可能会导致服务器数据更新，此时浏览器未发送请求，则会造成延迟</p><p>​               2-由于定时要向服务器发送请求，会造成服务器压力过大</p><p>（2）长轮询：浏览器发出ajax请求，服务器端收到请求后，会阻塞请求直到有数据或请求超时才返回</p><p>对比：由于有等待的过程，所以间隔时间可以长一些，相对于轮询对服务端造成的压力小。</p><p>并且由于必须收到数据才可返回，相对于轮询的延迟也会小。</p><p>（3）SSE 服务器发送事件</p><p>是服务端打开的和客户端之间的一个单向通道。  服务端相应的不再是一次性的数据包，而是text&#x2F;event-stream类型的数据流信息。  服务器有数据变更时将数据流式传输到客户端。</p><p>（4）WebSocket：如上。</p><p>补充：全双工：允许数据在两个方向上同时传输。</p><p>​           半双工：允许数据在两个方向上传输，但是同一个时间段内只允许一个方向上传输。</p><p>JAVA WebSocket应用由一系列的EndPoint组成。EndPoint是一个java对象，代表WebSocket链接的一端</p><p>每一个客户端，服务端都会创建一个EndPoint与之一对一对应，对于服务端，我们可以视为处理具体WebSocket消息的接口</p><p>EndPoint实例在WebSocket握手时创建，并在客户端与服务端连接过程中有效，最后在连接关闭时结束</p><p>服务端API</p><p>发送消息：1-服务端接受客户端发送的数据 常用：注解式@OnMessage</p><p>​         2-服务端推送数据给客户端：由RemoteEndpoint完成，实例由Session维护</p><p>​         通过session.getBasicRemote获取同步消息发送的实例，调用sendXXX()发送消息</p><p>​         通过session.getAsyncRemote获取异步消息发送的实例，调用sendXXX()发送消息</p><h2 id="AOP-面向切面"><a href="#AOP-面向切面" class="headerlink" title="AOP:面向切面"></a>AOP:面向切面</h2><p>动态代理是面向切面编程最主流的实现。而springAOP是spring框架的高级技术，旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程。对特定的方法功能进行加强或改变其功能。</p><p>好处：代码无侵入，减少重复代码，提高开发效率，维护方便</p><p>核心概念</p><p>（1）连接点：joinPoint，可以被AOP控制的方法（暗含方法执行时的相关信息）</p><p>通过joinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名，方法名，方法参数。 </p><p>joinPoint可获得方法的签名，而方法签名包含了方法的名称，返回类型及参数列表</p><p>（2）通知：Advice，指那些重复的逻辑，也就是共性功能（最终体现为一个方法）</p><p>（3）切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法被执行时被应用，通常通过切点表达式实现其功能。</p><p>区别：连接点时程序中所有潜在的可插入通知的位置，切入点则是从这些连接点筛选出来的，实际要附加通知的具体位置</p><p>（4）切面：Aspect，描述通知与切入点的对应关系（通知加切入点）</p><p>（5）目标对象：Target,通知所应用的对象</p><p>切点表达式（带？可省略）execution(访问修饰符？返回值 包名.类名.?方法名（方法参数）throws 异常？)</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理是在运行时动态的为对象创建代理的技术</p><table><thead><tr><th align="center"></th><th align="center">必须实现接口</th><th align="center">支持拦截public方法</th><th align="center">支持拦截protected方法</th><th align="center">拦截默认作用域方法</th></tr></thead><tbody><tr><td align="center">JDK动态代理</td><td align="center">是</td><td align="center">是</td><td align="center">否</td><td align="center">否</td></tr><tr><td align="center">CGLIB代理</td><td align="center">否</td><td align="center">是</td><td align="center">是</td><td align="center">是</td></tr></tbody></table><p>虽然CGLIB代理支持拦截非public作用域方法调用，但不同对象交互是，建议还是以public方法调用为主</p><h2 id="文件上传（阿里云OSS）"><a href="#文件上传（阿里云OSS）" class="headerlink" title="文件上传（阿里云OSS）"></a>文件上传（阿里云OSS）</h2><h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><p>前往阿里云官方完成注册等流程，新建一个bucket，获取到如下四个数据 access-key-id  access-key-secret  endpoint  bucket-name</p><p>写在配置文件中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">alioss:</span></span><br><span class="line">  <span class="attr">access-key-id:</span> </span><br><span class="line">  <span class="attr">access-key-secret:</span> </span><br><span class="line">  <span class="attr">endpoint:</span> </span><br><span class="line">  <span class="attr">bucket-name:</span> </span><br></pre></td></tr></table></figure><p>后端相应的接口</p><ul><li>接受上传来的文件</li><li>将文件存储起来（OSS）</li><li>返回文件的url</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/common&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AliOssUtil aliOssUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt;upload(MultipartFile file)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">            <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">ObjectName</span> <span class="operator">=</span> UUID.randomUUID().toString()+extension;</span><br><span class="line">            <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> aliOssUtil.upload(file.getBytes(), ObjectName);</span><br><span class="line">            <span class="keyword">return</span> Result.success(filePath);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中所用到的工具类(有阿里云官方代码改造而来)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliOssUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要为自己获取到的</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objectName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(<span class="type">byte</span>[] bytes, String objectName)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">        <span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建PutObject请求。</span></span><br><span class="line">            ossClient.putObject(bucketName, objectName, <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OSSException oe) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught an OSSException, which means your request made it to OSS, &quot;</span></span><br><span class="line">                    + <span class="string">&quot;but was rejected with an error response for some reason.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Message:&quot;</span> + oe.getErrorMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Code:&quot;</span> + oe.getErrorCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;Request ID:&quot;</span> + oe.getRequestId());</span><br><span class="line">            System.out.println(<span class="string">&quot;Host ID:&quot;</span> + oe.getHostId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException ce) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught an ClientException, which means the client encountered &quot;</span></span><br><span class="line">                    + <span class="string">&quot;a serious internal problem while trying to communicate with OSS, &quot;</span></span><br><span class="line">                    + <span class="string">&quot;such as not being able to access the network.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Message:&quot;</span> + ce.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ossClient != <span class="literal">null</span>) &#123;</span><br><span class="line">                ossClient.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件访问路径规则 https://BucketName.Endpoint/ObjectName</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;https://&quot;</span>);</span><br><span class="line">        stringBuilder</span><br><span class="line">                .append(bucketName)</span><br><span class="line">                .append(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">                .append(endpoint)</span><br><span class="line">                .append(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">                .append(objectName);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;文件上传到:&#123;&#125;&quot;</span>, stringBuilder.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
